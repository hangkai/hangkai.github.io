<?xml version="1.0" encoding="UTF-8"?>
<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">

    
  <url>
    <loc>www.lkh.im/2014/12/30/Shell%E7%BC%96%E7%A8%8B%E6%9E%81%E7%AE%80%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5/</loc>
    <lastmod>2014-12-30T09:28:03.000Z</lastmod>
    <data>
        <display>
        <title>Shell编程极简入门实践</title>
        <pubTime>2014-12-30T09:04:40.000Z</pubTime>
        
        <tag>shell </tag>
         
        <tag>linux </tag>
         
         <content><![CDATA[<ol>
<li>写在前面</li>
</ol>
<p>程序员多多少少都会和命令行打交道，一些常用的命令，比如cd、ls、ping等等，使用起来可能问题不大。但大多数人对Shell编程的了解程度，可能仅止于那几个最常用的命令。当需要更复杂的命令或者需要写一个脚本来进行批处理的时候，很多人可能感到头疼。而Unix/Linux复杂多变而又不太直观的命令常常让初学者望而却步。比如像这样的语句echo “123 abc” | sed ‘s/[0-9][0-9]*/&amp; &amp;/‘的语句，再比如那些以-开头的参数（-l -n -a等等），即使从网上找到了可能符合自己要求的代码，也往往因为看不懂而无法修改化为己用。<br>这个极简教程，或者说笔记，针对的是正是这部分读者。具体地说，通过学习这篇文档，你将获得以下技能：<br>    熟练掌握Unix/Linux下的最常用命令及其最常见用法；<br>    能够编写脚本，对文件进行批处理，对一些网络任务进行自动化等等；<br>    避免写脚本过程中的最常见错误；<br>    (Hopefully)可以借此消除对命令行的恐惧；</p>
<p>这个教程的特点是：<br>    不求全面，只求实用。只覆盖最常用的命令及其用法；<br>    以大量例子为导向；<br>    一边阅读一边动手写例程的话，大约只需要1.5-2.5小时的时间；</p>
<p>这篇文档假定你是在Linux/Unix环境下，比如Ubuntu, 比如Mac OS X。同时假定你至少了解一门其它的编程语言。这个教程的代码均在Mac OS下测试过，由于各种shell的标准差别很小，（有充足的理由相信）在别的平台应该也都能顺利运行。</p>
<ol>
<li>Hello World</li>
</ol>
<p>首先打开你用得最顺手的文本编辑器，在第一、二行分别打入</p>
<pre><code><span class="shebang">#!/bin/bash</span>
<span class="built_in">echo</span> <span class="string">"Hello, World!"</span>
</code></pre><p>保存文件，文件可保存在你喜欢的文件夹，扩展名选择.sh，比如这样的文件：tutorial.sh。</p>
<p>接着，打开命令行工具Terminal，首先将工作目录改到你保存文件的文件夹，比如如果你将tutorial.sh放在/Users/Steven/code,则在命令行里执行以下操作</p>
<pre><code><span class="built_in">cd</span> /Users/Steven/code
</code></pre><p>cd是change directory的意思，因为我们要执行tutorial.sh这个脚本，所以我们要先将工作目录转到这个脚本对应的文件夹下面。接着，在命令行继续输入</p>
<pre><code>chmod +<span class="keyword">x</span> tutorial.<span class="keyword">sh</span>
</code></pre><p>chmod是change mode，+x的意思是将tutorial.sh变为一个可执行的文件。</p>
<p>接下来，我们就可以运行tutorial.sh这个脚本了。在命令行里打入</p>
<pre><code>./tutorial.<span class="keyword">sh</span>
</code></pre><p>如无意外，你将看到命令行里返回Hello, World!这个字符串！请注意，文件名前面的./是必不可少的，它告诉系统，就在当前的目录查找一个叫tutorial.sh的文件，如果没有./，系统会只在系统目录里面查找（准确来说是PATH变量定义的路径）。</p>
<p>我们回头来看看tutorial.sh里面的程序，目前它只有两行：</p>
<pre><code><span class="shebang">#!/bin/bash</span>
<span class="built_in">echo</span> <span class="string">"Hello, World!"</span>
</code></pre><p>-#!是一个标记，它告诉系统该去哪里去寻找能“解释”tutorial.sh的解释器。 echo是回响的意思，意思是说echo后面的那一串东西，都会在命令行显示出来。它和其它语言的print是类似的。</p>
<p>就这样，我们完成了一个最简单的bash scripting的程序编写。这里面有几点需要注意：</p>
<pre><code>执行脚本文件前，先要<span class="built_in">cd</span>到文件所在的目录；
执行脚本文件前，先要chmod +x tutorial.sh将其变为可执行程序；
脚本文件的第一行，记得写上<span class="comment">#!/bin/bash。</span>
</code></pre><ol>
<li>整数和字符串</li>
</ol>
<p>变量的定义很简单，按照以下格式就可以了：</p>
<pre><code><span class="attribute">NAME</span>=<span class="string">var</span>
</code></pre><p>比如定义一个字符串：</p>
<pre><code>NAME=<span class="string">'Steven'</span>
</code></pre><p>比如定义一个整型变量：</p>
<pre><code><span class="attribute">NUM</span>=<span class="string">3</span>
</code></pre><p>这里有几点要注意，一是变量的名字，虽然大小写不限，但按照惯例一般采用全大写的方式。第二点特别重要，让我们做一个小实验来说明一下。打开刚才的那个tutorial.sh文件，将之前的内容清空，并打入</p>
<pre><code><span class="shebang">#!/bin/bash</span>
NAME = <span class="string">'Steven'</span>
<span class="built_in">echo</span> <span class="variable">$NAME</span>
</code></pre><p>如果你是直接复制以上的代码段，那么命令行应该会出现以下错误信息：</p>
<pre><code>./tutorial.sh: <span class="built_in">line</span> <span class="number">2</span>: NAME: <span class="command"><span class="keyword">command</span> <span class="title">not</span> <span class="title">found</span></span>
</code></pre><p>出现这个错误，是因为：定义变量时，=的前面和后面，都是不能有空格的！这一点可能和其它语言不一样，但请务必注意。因为出现这类错误时，报错信息定位的栏数（line 2），是指向你引用变量的那一段代码，而不是定义变量的那一行，因此debug起来可能不是那么直观。</p>
<p>于是，我们把代码改为：</p>
<pre><code><span class="shebang">#!/bin/bash</span>
NAME=<span class="string">'Steven'</span>
<span class="built_in">echo</span> <span class="variable">$NAME</span>
</code></pre><p>命令行将显示Steven。</p>
<p>从上面的例子我们也可以看到，当你定义了一个变量，要引用它时，要在前面加上$。变量名两边可以加上花括号，比如这样${NAME}。花括号不是必须的，但最好养成加上的习惯。因为在某些情况下，不加花括号可能引发歧义[1]:</p>
<pre><code><span class="shebang">#!/bin/bash</span>
NAME=<span class="string">'Steven'</span>
<span class="built_in">echo</span> <span class="string">"My name is <span class="variable">${NAME}</span>SLXie."</span>
</code></pre><p>可想而知，如果没有花括号，NAME和后面的SLXie就无法区分了。</p>
<p>对于字符串变量，既可以用单括号，比如’Steven’，也可以用双括号”Steven”，它们之间有微妙而繁杂的区别，在这里我们先记住一点，当字符串里面包含对某个变量的引用时，必须用双括号。比如上面的”My name is ${NAME}SLXie.”。请试着将它的双括号改为单括号，并观察它的输出结果。</p>
<p>单括号会将被引用字符串中的几乎所有特殊字符当作普通字符处理，比如上面的$，单括号时只把它当作一个普通的美元符号输出。</p>
<p>再看一个例子，试着在脚本分别输入这两行，并观察它们的输出。</p>
<pre><code><span class="built_in">echo</span> <span class="string">"Here is <span class="variable">$50</span>."</span>
<span class="built_in">echo</span> <span class="string">'Here is $50.'</span>
</code></pre><p>在这里插播一句，看这个教程的时候，最好是看到那里，就动手写到哪里。写的时候，不要直接复制粘贴，而是试着手打代码到编辑器里面。有时候代码里有一些微小而琐碎的东西，一定要自己打一遍才能记得牢。比如，一开始可能容易将#!/bin/bash打成#/bin/bash，或者#!bin/bash。</p>
<p>花括号{}也可以用来对字符串进行某些操作。比如下面这个例子：</p>
<pre><code><span class="shebang">#!/bin/bash</span>
USERNAME=<span class="string">'StevenSLXie'</span>
<span class="built_in">echo</span> <span class="string">"My name is <span class="variable">${USERNAME}</span>. People usually call me <span class="variable">${USERNAME:0:6}</span>."</span>
</code></pre><p>它会输出：</p>
<pre><code>My name <span class="keyword">is</span> StevenSLXie. People usually <span class="built_in">call</span> <span class="keyword">me</span> Steven.
</code></pre><p>这时候，${USERNAME:0:6}的作用是取字符串的一部分。第一个数字0是指截取的起始部分，则第二个数字6则是指截取的长度。再比如${#USERNAME}则是获取字符串的长度。更多的字符串用法，我们将在后面的正则表达式哪一节看到。</p>
<ol>
<li>数组</li>
</ol>
<p>数组可以这样简单粗暴地定义：</p>
<pre><code>NAMES[<span class="number">0</span>]=<span class="string">'Steven'</span>
NAMES[<span class="number">1</span>]=<span class="string">'Peter'</span>
NAMES[<span class="number">2</span>]=<span class="string">'David'</span>
</code></pre><p>当数组体量太大时，这样定义未免麻烦，因此我们也可以用一行声明的方式来定义：</p>
<pre><code><span class="keyword">declare</span> <span class="operator">-a</span> NAMES=(<span class="string">'Steven'</span> <span class="string">'Peter'</span> <span class="string">'David'</span>)
</code></pre><p>用declare -a来声明，后面一次性定义所有数组元素。请注意，在这里，整个数组用小括号括起来，而每个数组元素之间，是用空格来隔开的，而不是逗号或者其它。</p>
<p>访问数组的其中一个元素，和其它语言没什么不同。在你声明好数组之后，就可以访问数组元素了：</p>
<pre><code><span class="built_in">echo</span> <span class="variable">${NAMES[0]}</span>
<span class="built_in">echo</span> <span class="variable">${NAMES[2]}</span>
<span class="built_in">echo</span> <span class="variable">${NAMES[*]}</span>
</code></pre><p>${NAMES[<em>]}或者${NAMES[@]}表示访问所有元素。而${#NAMES[</em>]}则返回数组长度。请注意它和${#NAMES}的区别，后者是返回NAMES里面第一个元素的长度，相当于${#NAMES[0]}。</p>
<p>一个数组声明并定义后，我们仍可以二次定义它，比如下面的代码是在原来的数组基础上再添加一个人名。</p>
<pre><code><span class="keyword">declare</span> <span class="operator">-a</span> NAMES=(<span class="string">'Steven'</span> <span class="string">'Peter'</span> <span class="string">'David'</span>)
<span class="built_in">echo</span> <span class="variable">${#NAMES[*]}</span>
NAMES=(<span class="string">"<span class="variable">${NAMES[*]}</span>"</span> <span class="string">'Nancy'</span>)
<span class="built_in">echo</span> <span class="variable">${NAMES[*]}</span>
</code></pre><p>命令行将返回：</p>
<pre><code>3
Steven Peter David Nancy
</code></pre><ol>
<li>运算符<br>4.1 算术运算符</li>
</ol>
<p>Shell编程里的算术运算符和大多数编程语言很类似，主要是这些+ - * / %等。如果你试着在命令行里执行运算的话，比如输入以下算式：</p>
<pre><code>2 + 2
</code></pre><p>会得到：</p>
<pre><code>-<span class="ruby"><span class="symbol">bash:</span> <span class="number">2</span><span class="symbol">:</span> command <span class="keyword">not</span> found</span>
</code></pre><p>这条错误信息。这是因为命令行的逻辑是它会把一行命令的第一个词当作是命令，在系统中寻找与之匹配的执行语句，因为在这里它会认为2是一个命令，而显然它不可能找到这个命令。要想执行运算，我们在命令行里打入</p>
<pre><code><span class="type">expr</span> <span class="number">2</span> + <span class="number">2</span>
</code></pre><p>输出结果是4。expr是一个常用命令，evaluate an expression的意思。注意，这里数字和运算符之间，必须有一个空格。不然的话，如果你输入，</p>
<pre><code><span class="type">expr</span> <span class="number">2</span>+<span class="number">2</span>
</code></pre><p>则会输出</p>
<pre><code>2+2
</code></pre><p>这种情况下，expr会把后面的2+2当成一个字符串，而evaluate一个字符串的结果，自然就是它本身了。算术运算当然也可以用变量，比如：</p>
<pre><code><span class="keyword">VAR</span>=<span class="number">5</span>
expr <span class="number">2</span> + ${<span class="keyword">VAR</span>}
</code></pre><p>其它的算术运算符大体类似，但有一个要特别注意，如果你进行乘法运算，比如:</p>
<pre><code><span class="type">expr</span> <span class="number">2</span> * <span class="number">15</span>
</code></pre><p>会输出：</p>
<pre><code><span class="attribute">expr</span>: <span class="string">syntax error</span>
</code></pre><p>这是因为*是一个特殊的字符（后面还会介绍到），而当要表达其原来的意思是，我们需要在它前面加上下划线\。就像这样：</p>
<pre><code><span class="type">expr</span> <span class="number">2</span> \* <span class="number">15</span>
</code></pre><p>4.2 关系判断运算符</p>
<p>Shell提供了丰富的关系判断运算符，先来看一个例子，在tutorial.sh加入以下代码：</p>
<pre><code>A=<span class="number">10</span>
B=<span class="number">15</span>

<span class="keyword">if</span> [ <span class="variable">$A</span> <span class="operator">-eq</span> <span class="variable">$B</span> ]
<span class="keyword">then</span>
    <span class="built_in">echo</span> <span class="string">'True'</span>
<span class="keyword">else</span>
    <span class="built_in">echo</span> <span class="string">'False'</span>
<span class="keyword">fi</span>
</code></pre><p>这是一个if条件判别语句(后面再细讲)。-eq判断运算符左右两边是否相等，如果是，则返回True，不然就返回False。关系判断运算符的基本格式是[ VAR1 OPERATOR VAR2 ]，用一个中括号括起来，这里有一点细节要注意，中括号和变量之间，需要有空格隔开。所以像[$A -eq $B]是会报错的。（不如自己写段代码试一试？）</p>
<p>完整的关系判断运算符文档可以看这里：Unix Basic Operator<br>4.3 逻辑运算符</p>
<p>与主流编程语言用&amp;&amp; and || or来做逻辑判断稍有不同，Shell编程里，与逻辑和或逻辑分别是用-o和-a来表示的。看看下面这个例子：</p>
<pre><code>A=<span class="number">10</span>
B=<span class="number">15</span>

<span class="keyword">if</span> [ <span class="variable">$A</span> <span class="operator">-lt</span> <span class="number">8</span> <span class="operator">-a</span> <span class="variable">$B</span> <span class="operator">-gt</span> <span class="number">8</span> ]
<span class="keyword">then</span>
    <span class="built_in">echo</span> <span class="string">'True'</span>
<span class="keyword">else</span>
    <span class="built_in">echo</span> <span class="string">'False'</span>
<span class="keyword">fi</span>
</code></pre><p>这是判断变量A是否小于8且变量B是否大于B。</p>
<p>完整的关系判断运算符文档可以看这里：Unix Basic Operator</p>
<ol>
<li>if条件判断、while循环、for循环</li>
</ol>
<p>if | while | for语句和其它主流语言很相似，因此用起来应该不是大问题。值得注意的可能是以下几个小点：</p>
<pre><code><span class="keyword">if</span>语句的格式是<span class="keyword">if</span>...<span class="keyword">then</span>...<span class="keyword">elif</span>...fi。注意，这里用fi来标记一个条件判断的结束。嗯，感觉是一种很调皮的设定。
所有的<span class="keyword">while</span>和<span class="keyword">for</span>语句，其执行的语句都始于<span class="keyword">do</span>，终于<span class="keyword">done</span>。
<span class="keyword">for</span>的格式是<span class="keyword">for</span> VAR <span class="keyword">in</span> ARRAY，是Python的样式，和经典的C <span class="keyword">for</span>循环可能稍有不同。
</code></pre><p>下面我们用一个例子来感受一下这三种语句。</p>
<pre><code><span class="built_in">echo</span> <span class="string">'Shall we begin the demo?(y/n)'</span>
<span class="built_in">read</span> ANS

A=<span class="number">0</span>
<span class="keyword">declare</span> <span class="operator">-a</span> B=(<span class="number">0</span>)

<span class="keyword">if</span> [ <span class="variable">$ANS</span> = <span class="string">'y'</span> ]
<span class="keyword">then</span>
    <span class="built_in">echo</span> <span class="string">'Output the results of the while loop'</span>
    <span class="keyword">while</span> [ <span class="variable">$A</span> <span class="operator">-lt</span> <span class="number">10</span> ]
    <span class="keyword">do</span>
        <span class="built_in">echo</span> <span class="variable">$A</span>
        A=`expr <span class="variable">$A</span> + <span class="number">1</span>`
        B=(<span class="variable">${B[*]}</span> <span class="variable">$A</span>)
    <span class="keyword">done</span>
<span class="keyword">else</span>
    <span class="built_in">echo</span> <span class="string">'Not ready for the demo yet.'</span>
<span class="keyword">fi</span>

<span class="built_in">echo</span> <span class="string">'Output the results of the for loop.'</span>
<span class="keyword">for</span> I <span class="keyword">in</span> <span class="variable">${B[*]}</span>
    <span class="keyword">do</span>
        <span class="built_in">echo</span> <span class="variable">$I</span>
    <span class="keyword">done</span>
</code></pre><p>第二行的read在这个文档是第一次出现，它的功能是从Terminal里读取一行，并将这一行内容赋给read后面的那个变量。在这个例子里，我们询问用户是否要开始demo，当得到肯定回答后，用户的回答（假定是y），将被赋给ANS这个变量。</p>
<p>接着，我们用一个if判断语句，如果用户回答是y，则执行while循环。while循环的内容比较简单，在每一次循环里，先打印出A的值，接着将A的值加一，然后将每一个得到的新的A放进数组B里面。当A大于等于10的时候，退出循环。</p>
<p>最后是一个for循环，for的功能是将数组B里面的元素依次打印出来。</p>
<p>这里要补充一点，在对A加一的时候，我们使用的是A=<code>expr $A + 1</code>，如果你试图使用类似A=$A + 1这样的赋值，将会报错。这是因为如前所述，每一个算术运算，都需要用expr来算出它的结果。那expr两边的<code>`又是怎么回事呢？这里的</code> <code>其实是命令输出的引用，我们知道expr $A + 1本身是一个命令语句，而当我们要引用这个语句的执行结果的时候，就要加上</code> <code>了。举一个比较容易理解的例子吧：如果你在命令行输入date，就会输出系统的当前时间，这时候date是一个命令，但如果你要将date这个命令的执行结果赋给一个变量D，就要D=</code>date<code>。同样的，如果我们要将5 + 25的结果赋给一个变量SUM，则需要SUM=</code>expr 5 + 25`。</p>
<p><code> </code>在键盘上的位置是在Tab上面，1的左边。</p>
<p>还有一点要注意，当我们对一个已经定义过的变量进行重新赋值的时候，是不需要加$的，上面的例子A=<code>expr $A + 1</code>和B=(${B[*]} $A)里，等式左边的变量都不需要加$。</p>
<ol>
<li>函数</li>
</ol>
<p>Shell脚本里当然可以定义函数。比如这样的：</p>
<pre><code><span class="function"><span class="title">hello</span></span>(){
    <span class="built_in">echo</span> <span class="string">"Hello World!"</span>
}
</code></pre><p>函数可以直接调用，比如下面这个脚本：</p>
<pre><code><span class="shebang">#!/bin/bash</span>
<span class="function"><span class="title">hello</span></span>(){
    <span class="built_in">echo</span> <span class="string">"Hello World!"</span>
}

hello
</code></pre><p>注意，但函数没有参数时，调用只需要写上函数名，而不是hello()之类的。</p>
<p>Shell函数的特殊之处，在于它参数传递的形式，具体地说，参数并不是像别的语言一样，写在括号里面，而是类似下面这个例子：</p>
<pre><code><span class="function"><span class="title">intro</span></span>(){
    <span class="built_in">echo</span> <span class="string">"There are <span class="variable">$1</span> people here. They are <span class="variable">$2</span>, <span class="variable">$3</span>."</span>
}
</code></pre><p>Shell用$1 $2这样的特殊记号来标记函数参数。而$0则是函数名，$n表示第n个参数。调用上面的intro函数，则是这个样子：</p>
<pre><code><span class="keyword">intro</span> <span class="number">2</span> <span class="string">'Steven'</span> <span class="string">'David'</span>
</code></pre><p>命令行的输出则是：</p>
<pre><code>There are <span class="number">2</span> people <span class="keyword">here</span>. They are Steven, David.
</code></pre><p>参数不是写在括号里，而是在函数名之后依次排列，并以空格隔开。</p>
<p>函数也可以有返回值，比如：</p>
<pre><code>hello(){
    <span class="literal">A</span>=<span class="escape">`e</span>xpr <span class="number">5</span> \* <span class="number">10</span><span class="escape">`
</span>    <span class="keyword">return</span> $<span class="literal">A</span>
}
</code></pre><p>返回变量A的值。请注意，这里获取返回值的方式和其它语言可能不太一样。并不是A=hello，而是：</p>
<pre><code><span class="attribute">hello
RET</span>=<span class="string">$?</span>
</code></pre><p>$?是一个特殊字符，它保留上一个命令的执行结果。因此，当我们要获取hello函数的返回值时，就在调用该函数后，紧接着将$?赋给存储返回值的变量ret。在这里，这两句命令是必须紧挨着的，如果中间还有其它语句，则$?会返回最近一次的命令执行结果，而不一定是hello的返回值。</p>
<ol>
<li>sed和正则表达式</li>
</ol>
<p>正则表达式是一种特殊的字符串，用来描述一串具有某种共同特征的字符串。在进行批处理的时候，正则表达式有着异常强大的应用。</p>
<p>sed则是一个流编辑器(stream editor)，它读入一个输出，并通过加工处理，输出经处理后的 文件/字符串 输出。下面我们通过一系列例子，来掌握sed的基本应用。</p>
<p>首先我们要来新建一些txt文件供sed处理。在命令行输入：</p>
<pre><code><span class="built_in">mkdir</span> <span class="keyword">files</span>
<span class="keyword">cd</span> <span class="keyword">files</span>
touch test-<span class="number">1</span>.txt
touch test-<span class="number">2</span>.txt
touch test-<span class="number">3</span>.txt
<span class="keyword">cd</span> ../
</code></pre><p>第一行mkdir是在当前目录下新建一个叫files的文件夹。然后我们cd到新的文件夹里，在里面用touch新建三个txt文档。接着，通过cd ../回到上级目录，也就是我们的tutorial.sh所在的目录里。</p>
<p>然后，分别打开那三个txt文件，将以下几行字符串拷贝到文件里。</p>
<p>This is a file with several lines<br>some of which are blank lines<br>for example, the line that follows is blank</p>
<p>But this line has several characters.</p>
<p>And this marks the end of the file.</p>
<p>接着，打开我们的tutorial.sh，将之前内容清空，只留下第一行的#!/usr/bash。在里面输入：</p>
<pre><code><span class="built_in">cd</span> files
FILE=test-<span class="number">1</span>.txt

sed -i.tmp <span class="string">"/^$/d"</span> <span class="variable">$FILE</span>
</code></pre><p>保存后运行./tutorial.sh。然后打开test-1.txt，如无意外的话，你会看到文档变成这个样子：</p>
<p>This is a file with several lines<br>some of which are blank lines<br>for example, the line that follows is blank<br>But this line has several characters.<br>And this marks the end of the file.</p>
<p>所有的空行被删除了。我们来看看sed -i.tmp “/^$/d” $FILE这句命令。其中”/^$/d”描述了sed作用于什么模式(pattern)，以及操作(action)，它的基本结构是这样的”/pattern/action”。其中pattern里面是一个正则表达式，表面了我们要寻找什么样的字符串(pattern match)，找到之后，则是对这个字符串进行操作(action)。在我们这个例子里，我们的正则表达式是”^$”，其中^是标记一个字符串的开始，而$是标记一个字符串的结束。在这里，开始和结束连在一起，表示我们要寻找的是一个空字符串，而对它的操作是d，delete的意思。整个句子合起来就是，sed会打开test-1.txt，逐行扫描，找到空行，删除掉空行。</p>
<p>而sed前面的 -i则是in place的意思，就是说我们这个操作是直接对目标文件下手的。这样的修改通常是比较危险的（万一改错了呢），所以一个安全的办法是在-i后面加上-i.tmp，意思是每次改动，我们都会保留一个后缀为.tmp的备份文件。于是你打开文件夹的话，会看到多出了一个test-1.txt.tmp。如果你确认你的改动没有问题之后，就可以把这个备份文件删掉了。备份文件的扩展名可以随意，因为当你需要它的时候总是需要把它改回txt的。但最好扩展名不要和文件夹的已有文件重复。</p>
<p>接着你可以试试将上面的sed语句改为：</p>
<pre><code>sed <span class="operator">-e</span> <span class="string">"/^$/d"</span> test-<span class="number">2</span>.txt
</code></pre><p>这时你会发现改动后的结果，在命令行显示出来了，而原文件并不会改动。</p>
<p>再来看下面的语句：</p>
<pre><code>sed <span class="operator">-e</span> <span class="string">"1,3d"</span> test-<span class="number">2</span>.txt
</code></pre><p>这个语句的意思，就是删除test-2.txt中的第一到第三行。观察输出可以看到，前三行被删除了。类似地，sed -e “2,4!d” test-2.txt则是指，除了2-4行，其他都删掉。sed -e “d” test-2.txt 则是删除文档里面的全部内容。请注意，为了避免频繁改动文档，以上几个命令都是用的-e，改动是体现在命令行的输出的。如果要直接对文档进行改动，请用-i.tmp，或者分开写为-i ‘.tmp’。在Mac OS X的Bash Shell里面，似乎提供一个备份文件的扩展名是必须的，而在Linux平台则似乎是可选的。</p>
<p>更为常见的sed的应用，是用它来进行替换。看看下面的例子：</p>
<pre><code>sed <span class="operator">-e</span> <span class="string">'s/But/but/'</span> test-<span class="number">2</span>.txt
</code></pre><p>命令行的输出：</p>
<p>This is file with several lines<br>some of which are blank lines<br>for example, the line that follows is blank</p>
<p>but this line has several characters.</p>
<p>And this marks the end of the file.</p>
<p>可以观察到，首字母大写的But被替换成but。替换的基本格式是’s/a/b/‘，a和b分别代表替换前和替换后。我们再来多看几个例子，首先将test-2.txt文档的内容改为：</p>
<p>1.This is file with several lines<br>2.some of which are blank lines<br> for example, the line that follows is blank</p>
<p>7.But this line has several characters.</p>
<p> And this marks the end of the file.</p>
<p>第三行和最后一行前面有一个空格。接着我们在tutorial.sh里面加入以下命令：</p>
<pre><code><span class="title">sed</span> -i <span class="string">'.tmp'</span> <span class="string">'s/^[ 1-3]//'</span> test-<span class="number">2</span>.txt
</code></pre><p>你会看到以下输出：</p>
<p>.This is file with several lines<br>.some of which are blank lines<br>for example, the line that follows is blank</p>
<p>7.But this line has several characters.</p>
<p>And this marks the end of the file.</p>
<p>在这个例子里，正则表达式^[ 1-3]的^表示字符串的开始，而中括号表示匹配任意一个在中括号里面的字符。我们的中括号里面有空格以及数字1-3，而之后*表示零到任意多个任意字符。于是，sed根据正则表达式的要求去逐行扫描，找出“以空格或者数字1-3开头的行”。</p>
<p>找到之后干什么呢？这就要看第二个/后面的内容了，而我们发现第二个/和第三个/之间并没有内容。这是说，找到了符合要求的这个字符串，就将其替换为空字符。于是你可以看到以上的输出了。第一行第二行的数字被移除，第三行和最后一行的空格被移除，而第五行的数字7则不受影响。</p>
<p>保留新的test-2.txt，我们继续执行以下命令：</p>
<pre><code><span class="title">sed</span> -i <span class="string">'.tmp'</span> <span class="string">'s/[!.]$/;/'</span> test-<span class="number">2</span>.txt
</code></pre><p>这个命令则是找出以! .结尾的行，并一律改为以分号结尾。</p>
<p>我们继续在原有的文档操作，输入以下命令：</p>
<pre><code><span class="title">sed</span> -i <span class="string">'.tmp'</span> <span class="string">'s/^[. 1-9]*//;s/[;.!]$/ ENDING/'</span> test-<span class="number">2</span>.txt
</code></pre><p>这是两个替换命令一起来。首先，我们找出以. 或者数字1-9,或者空格开头的行，然后将其删掉。请注意，这里有一个<em>，它代表了任意多个（包括0）前一个字符的重复。比如如果一个行是以三个空格开头的，则加上</em>可以加之一并铲除，如果不加的话就只会匹配并删除第一个空格。两个合并命令之间以空格隔开。第二个命令是找出以分号句号或者感叹号结尾的行，代之以ENDING。</p>
<p>输出结果应该是：</p>
<p>This is file with several lines<br>some of which are blank lines<br>for example, the line that follows is blank</p>
<p>But this line has several characters ENDING</p>
<p>And this marks the end of the file ENDING</p>
<p>回头看这个命令，sed -i ‘.tmp’ ‘s/^[. 1-9]*//;s/[;.!]$/ ENDING/‘ test-2.txt。两个小时之前，如果你看到这么复杂的命令行的时候，很有可能因为看起来过于复杂而崩溃掉吧。但现在，你也能读、写这样复杂的命令了。恭喜！</p>
<p>让我们继续来看看sed的一些其它应用。</p>
<pre><code><span class="title">sed</span> -i <span class="string">'.tmp'</span> <span class="string">'s/^some.*//'</span> test-<span class="number">2</span>.txt
</code></pre><p>删除以some开头的行。其中.可以指代任意字符。</p>
<pre><code><span class="title">sed</span> -i <span class="string">'.tmp'</span> <span class="string">'s/....$//'</span> test-<span class="number">2</span>.txt
</code></pre><p>删除每行末尾的四个字符。</p>
<pre><code><span class="title">sed</span> -i <span class="string">'.tmp'</span> <span class="string">'s/But/but/g'</span> test-<span class="number">2</span>.txt
</code></pre><p>这个看起来有点熟悉对不对？如果你比较之前的语句，会发现多了一个g。在这里，如果不加g则只会替换每行的第一个But，而加g则会替换所有的But。如果你只是要替换某一个位置的But，比如第三个，则可以sed -i ‘.tmp’ ‘s/But/but/3’ test-2.txt。</p>
<p>除了删除和替换，sed还支持插入(insert/append)新的字符串。</p>
<p>比如下面的例子：</p>
<pre><code>sed -i <span class="comment">'.tmp' '3 a\</span>
just some random <span class="keyword">text</span><span class="comment">' test-2.txt</span>
</code></pre><p>它的功能是往test-2.txt的第三行后面添加just some random text这一新行。注意a\之后要另起一行，这里a是append的意思。如果a\改为i\，则是在前面加新行。i是insert的意思。</p>
<p>另外一个例子：</p>
<pre><code>sed -i <span class="comment">'.tmp' '$ a\</span>
just some random <span class="keyword">text</span><span class="comment">' test-2.txt</span>
</code></pre><p>在文件末尾处加上新行。</p>
<p>当然我们也可以用正则表达式要判别，比如：</p>
<pre><code>sed -i '.tmp' '/text/ i\
<span class="operator"><span class="keyword">INSERT</span> THIS <span class="keyword">BEFORE</span> EVERY LINE CONTAINING <span class="built_in">TEXT</span><span class="string">' test-2.txt</span></span>
</code></pre><p>在每一行包含text的行前面加入INSERT THIS BEFORE EVERY LINE CONTAINING TEXT。</p>
<p>更多的sed用法，可以参考：<a href="http://www.grymoire.com/Unix/Sed.html#uh-1" target="_blank" rel="external">http://www.grymoire.com/Unix/Sed.html#uh-1</a> 。</p>
<ol>
<li>grep</li>
</ol>
<p>grep相当于Unix/Linux命令行的Google，可以快速地找出包含某个字符串的文件。让我们先将当前目录移到files子文件夹，并显示该目录下的所有文件名。</p>
<pre><code><span class="keyword">cd</span> <span class="keyword">files</span>
<span class="keyword">ls</span>
</code></pre><p>如果你按照这个教程一路走下来，现在这个文件夹里面应该有test-1.txt test-2.txt test-3.txt几个文件，以及可能的备份文件。如果不是也不要紧。接下来我们执行一个grep，来找出test-1.txt里面包含’file’的那些行。</p>
<pre><code><span class="keyword">grep</span> <span class="string">"file"</span> test-<span class="number">1</span>.txt
</code></pre><p>正常的话会输出：</p>
<p>This is file with several lines<br>And this marks the end of the file.</p>
<p>这两行包含着file。</p>
<p>grep可以同时搜索多个文件，比如这样：</p>
<pre><code>grep <span class="string">"file"</span> <span class="keyword">test</span>-<span class="number">1.</span>txt <span class="keyword">test</span>-<span class="number">2.</span>txt
</code></pre><p>输出则是：</p>
<p>test-1.txt:This is file with several lines<br>test-1.txt:And this marks the end of the file.<br>test-2.txt:This is file with several li<br>test-2.txt:And this marks the end of the file END</p>
<p>格式是文件名:字符串。当然，罗列所有的文件名，有时候很不方便。这时候可以用上模糊搜索。比如这样：</p>
<pre><code><span class="title">grep</span> <span class="string">"file"</span> test-<span class="regexp">*.txt</span>
</code></pre><p>有时候你只想知道哪些文件包含了某个字符串，而对那一行的具体内容是什么并不重要，那么可以这样：</p>
<pre><code><span class="title">grep</span> -l <span class="string">"file"</span> test-<span class="regexp">*.txt</span>
</code></pre><p>系统会打印出包含file的文件名。有的时候你想多知道一点：不想打印出整行字符串，但想知道每个文件有几行包含file，那么可以：</p>
<pre><code><span class="title">grep</span> -c <span class="string">"file"</span> test-<span class="regexp">*.txt</span>
</code></pre><p>而有时候你想知道的非常多，不仅是文件名，出现了几行，而且具体的行数也要知道，那么可以：</p>
<pre><code><span class="title">grep</span> -n <span class="string">"file"</span> test-<span class="regexp">*.txt</span>
</code></pre><p>有的时候你想知道输出相反的结果：那些不包含file的行，那么可以：</p>
<pre><code><span class="keyword">grep</span> -<span class="keyword">vn</span> <span class="string">"file"</span> test-*.txt
</code></pre><p>grep当然也支持正则表达式。要知道，grep的全称就是global regular expression print。所以“你问我支持不支持，他的名字叫全局正则表达式打印器，怎么能不支持？”（请忽略一个蛤丝的老梗~）。</p>
<p>我们来看几个例子：</p>
<pre><code><span class="title">grep</span> <span class="string">"END$"</span> test-<span class="regexp">*.txt</span>
</code></pre><p>输出结尾为END的那些行。</p>
<pre><code><span class="title">grep</span> <span class="string">"file\|But"</span> test-<span class="regexp">*.txt</span>
</code></pre><p>输出含有file或者But的行。注意|前面需要用\。</p>
<p>如果我们要搜索包含characters.的行，正确的命令是这样的：</p>
<pre><code><span class="title">grep</span> <span class="string">'characters\.'</span> test-<span class="regexp">*.txt</span>
</code></pre><p>同时试一试grep ‘characters.’ test-*.txt，看看结果有什么不同。</p>
<ol>
<li>写一个脚本吧</li>
</ol>
<p>前面九节基本上覆盖了Shell编程最基本的内容，这一节我们来动手写一个脚本，一方面是把我们之前学到的东西复习一下，串联起来。另一方面，是将之前没有覆盖到的几个常用命令介绍一下。</p>
<p>我们的任务是在当前目录下，新建一个脚本final-script.sh。然后在脚本里新建一个文件夹final，在新文件夹里批量新建十个.txt文件，命名规则为final-test-n.txt。每个文件的文档内容”This is a test file…!!”。</p>
<p>接着，将十个文件的文件名从final-test-n.txt改为Final-test-n.txt。</p>
<p>然后，删除文件内容里面的标点符号。</p>
<p>接着，将文件内容全部变成大写。</p>
<p>将改动后的文件，拷贝一份到任意一个新的文件夹。</p>
<p>请注意，这当中会出现一些我们没学到的知识，如果你发现现有的知识不足以解决问题的话，请Google之。</p>
<p>下面是我写的脚本，为了便于理解，我将各个命令都分开写了。</p>
<pre><code><span class="shebang">#!/bin/bash</span>
mkdir final
<span class="built_in">cd</span> final

<span class="keyword">declare</span> <span class="operator">-a</span> NAME
NAME=(<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span>)


<span class="comment"># 创建新文件。</span>

<span class="keyword">for</span> I <span class="keyword">in</span> <span class="variable">${NAME[*]}</span>
    <span class="keyword">do</span>
        touch final-test-<span class="variable">${I}</span>.txt
    <span class="keyword">done</span>
</code></pre><p>  ‘# 往文档写入。这里使用的是echo，通过<code>&gt;</code>改变其默认输出。不妨思考一下如果用sed来实现会有什么问题？</p>
<pre><code><span class="keyword">for</span> F <span class="keyword">in</span> final-test-*.txt
    <span class="keyword">do</span>
        <span class="built_in">echo</span> <span class="string">'This is a test file...!!'</span> &gt; <span class="variable">$F</span>
    <span class="keyword">done</span>
</code></pre><p> ‘# 文件名首字母大写。注意echo和sed的连用，以及我们引用命令的一种新方法$(command)。还有mv这个新命令。</p>
<pre><code><span class="keyword">for</span> F <span class="keyword">in</span> final-test-*.txt
    <span class="keyword">do</span>
        NEW=$(<span class="built_in">echo</span> <span class="string">"<span class="variable">$F</span>"</span> | sed <span class="operator">-e</span> <span class="string">'s/^./F/'</span>)
        mv <span class="string">"<span class="variable">$F</span>"</span> <span class="string">"<span class="variable">$NEW</span>"</span>
    <span class="keyword">done</span>
</code></pre><p> ‘# 删除标点。</p>
<pre><code><span class="keyword">for</span> F <span class="keyword">in</span> *.txt
    <span class="keyword">do</span>
        sed -i.tmp <span class="string">'s/...!!$//'</span> <span class="variable">$F</span>
    <span class="keyword">done</span>
</code></pre><p> ‘# 大写。注意tr的使用。</p>
<pre><code><span class="keyword">for</span> F <span class="keyword">in</span> *.txt
    <span class="keyword">do</span>
        tr <span class="string">'[:lower:]'</span> <span class="string">'[:upper:]'</span> &lt; <span class="variable">$F</span> &gt; FILE2
        mv FILE2 <span class="variable">$F</span>
    <span class="keyword">done</span>

<span class="built_in">cd</span> ../
mkdir repo

<span class="built_in">cd</span> final
</code></pre><p> ‘# 复制文件。</p>
<pre><code><span class="keyword">for</span> F <span class="keyword">in</span> *.txt
    <span class="keyword">do</span>
        cp <span class="variable">$F</span> ../repo/<span class="variable">$F</span>
    <span class="keyword">done</span>
</code></pre>]]></content>
         
         
           
             
              <breadCrumb title="linux" url="www.lkh.im/categories/linux/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>www.lkh.im/2014/12/29/%E4%BD%BF%E7%94%A8Lock%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97/</loc>
    <lastmod>2014-12-29T08:53:37.000Z</lastmod>
    <data>
        <display>
        <title>使用Lock同步代码块</title>
        <pubTime>2014-12-29T08:47:54.000Z</pubTime>
        
        <tag>多线程 </tag>
         
        <tag>lock </tag>
         
         <content><![CDATA[<p>使用Lock同步代码块</p>
<p> Java提供另外的机制用来同步代码块。它比synchronized关键字更加强大、灵活。它是基于Lock接口和实现它的类（如ReentrantLock）。这种机制有如下优势：</p>
<p>它允许以一种更灵活的方式来构建synchronized块。使用synchronized关键字，你必须以结构化方式得到释放synchronized代码块的控制权。Lock接口允许你获得更复杂的结构来实现你的临界区。<br>    Lock 接口比synchronized关键字提供更多额外的功能。新功能之一是实现的tryLock()方法。这种方法试图获取锁的控制权并且如果它不能获取该锁，是因为其他线程在使用这个锁，它将返回这个锁。使用synchronized关键字，当线程A试图执行synchronized代码块，如果线程B正在执行它，那么线程A将阻塞直到线程B执行完synchronized代码块。使用锁，你可以执行tryLock()方法，这个方法返回一个 Boolean值表示，是否有其他线程正在运行这个锁所保护的代码。<br>    当有多个读者和一个写者时，Lock接口允许读写操作分离。<br>    Lock接口比synchronized关键字提供更好的性能。</p>
<h1 id="创建PrintQueue类，来实现打印队列"><h4>创建PrintQueue类，来实现打印队列</h4></h1>
<pre><code>package com.hang.thread.<span class="keyword">lock</span>;

import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

<span class="keyword">public</span> <span class="keyword">class</span> PrintQueue {

    <span class="keyword">private</span> final Lock queueLock=<span class="keyword">new</span> ReentrantLock();<span class="comment">//声明一个Lock对象，并且使用ReentrantLock类的一个新对象来初始化它。</span>

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printJob</span>(Object document){<span class="comment">//实现printJob()方法，它将接收Object对象作为参数，并且不会返回任何值。</span>
        queueLock.<span class="keyword">lock</span>();<span class="comment">//在printJob()方法内部，通过调用lock()方法来获取Lock对象的控制权。</span>
        <span class="keyword">try</span> {<span class="comment">//包含以下代码来模拟文档的打印：</span>
            Long duration=(<span class="keyword">long</span>)(Math.random()*<span class="number">10000</span>);
            System.<span class="keyword">out</span>.println(Thread.currentThread().getName()+ <span class="string">": PrintQueue: Printing a Job during "</span>+(duration/<span class="number">1000</span>)+
            <span class="string">" seconds"</span>);
            Thread.sleep(duration);
        } <span class="keyword">catch</span> (InterruptedException e) {
            e.printStackTrace();
        }<span class="keyword">finally</span> {
            queueLock.unlock();<span class="comment">//通过调用unlock()方法来释放Lock对象的控制</span>
        }
    }

}
</code></pre><h1 id="创建一个Job类，并指定它实现Runnable接口"><h4>创建一个Job类，并指定它实现Runnable接口</h4></h1>
<pre><code><span class="keyword">package</span> com.hang.thread.lock;

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Job</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{

    <span class="keyword">private</span> PrintQueue printQueue;<span class="comment">//声明一个PrintQueue类的对象，并通过实现类（Job类）的构造器来初始化这个对象。</span>

    <span class="keyword">public</span> <span class="title">Job</span>(PrintQueue printQueue) {
        <span class="keyword">this</span>.printQueue = printQueue;
    }

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {<span class="comment">//实现run()方法，它使用PrintQueue对象来发送一个打印任务。</span>
        System.out.printf(<span class="string">"%s: Going to print a document\n"</span>, Thread.
                currentThread().getName());
        printQueue.printJob(<span class="keyword">new</span> Object());
        System.out.printf(<span class="string">"%s: The document has been printed\n"</span>,
                Thread.currentThread().getName());
    }

}
</code></pre><h1 id="创建10个Job对象，并且使用10个线程来运行它们"><h4>创建10个Job对象，并且使用10个线程来运行它们</h4></h1>
<pre><code>package com.hang.thread.<span class="keyword">lock</span>;

<span class="keyword">public</span> <span class="keyword">class</span> Main {

        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
            PrintQueue printQueue = <span class="keyword">new</span> PrintQueue();<span class="comment">//创建一个共享的PrintQueue对象</span>
            Thread thread[] = <span class="keyword">new</span> Thread[<span class="number">10</span>];
            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {
                thread[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Job(printQueue), <span class="string">"Thread "</span> + i);
            }
            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {
                thread[i].start();
            }
        }

    }
</code></pre>]]></content>
         
         
           
             
              <breadCrumb title="多线程" url="www.lkh.im/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>www.lkh.im/2014/12/27/vi%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</loc>
    <lastmod>2014-12-27T07:52:04.000Z</lastmod>
    <data>
        <display>
        <title>vi基本操作</title>
        <pubTime>2014-12-27T07:42:37.000Z</pubTime>
        
        <tag>linux </tag>
         
        <tag>vi </tag>
         
         <content><![CDATA[<h3>vi有3个模式：插入模式、命令模式、低行模式。</h3>

<pre><code>插入模式：在此模式下可以输入字符，按ESC将回到命令模式。
命令模式：可以移动光标、删除字符等。
低行模式：可以保存文件、退出<span class="keyword">vi</span>、设置<span class="keyword">vi</span>、查找等功能(低行模式也可以看作是命令模式里的)。
</code></pre><h3>一、打开文件、保存、关闭文件(vi命令模式下使用)</h3>

<p>vi filename       //打开filename文件<br>:w       //保存文件<br>:w vpser.net        //保存至vpser.net文件<br>:q          //退出编辑器，如果文件已修改请使用下面的命令<br>:q!        //退出编辑器，且不保存<br>:wq         //退出编辑器，且保存文件</p>
<h3>二、插入文本或行(vi命令模式下使用，执行下面命令后将进入插入模式，按ESC键可退出插入模式)</h3>

<p>a      //在当前光标位置的右边添加文本<br>i       //在当前光标位置的左边添加文本<br>A     //在当前行的末尾位置添加文本<br>I      //在当前行的开始处添加文本(非空字符的行首)<br>O     //在当前行的上面新建一行<br>o     //在当前行的下面新建一行<br>R    //替换(覆盖)当前光标位置及后面的若干文本<br>J    //合并光标所在行及下一行为一行(依然在命令模式)</p>
<h3>三、移动光标(vi命令模式下使用)</h3>

<p>1、使用上下左右方向键</p>
<p>2、命令模式下：h   向左、j   向下 、k   向上、l  向右。<br>空格键 向右、Backspace  向左、Enter  移动到下一行首、-  移动到上一行首。</p>
<h3>四、删除、恢复字符或行(vi命令模式下使用)</h3>

<p>x         //删除当前字符<br>nx         //删除从光标开始的n个字符<br>dd      //删除当前行<br>ndd   //向下删除当前行在内的n行<br>u       //撤销上一步操作<br>U      //撤销对当前行的所有操作</p>
<h3>五、搜索(vi命令模式下使用)</h3>

<p>/vpser     //向光标下搜索vpser字符串<br>?vpser     //向光标上搜索vpser字符串<br>n           //向下搜索前一个搜素动作<br>N         //向上搜索前一个搜索动作</p>
<h3>六、跳至指定行(vi命令模式下使用)</h3>

<p>n+        //向下跳n行<br>n-         //向上跳n行<br>nG        //跳到行号为n的行<br>G           //跳至文件的底部</p>
<h3>七、设置行号(vi命令模式下使用)</h3>

<p>:set  nu     //显示行号<br>:set nonu    //取消显示行号</p>
<h3>八、复制、粘贴(vi命令模式下使用)</h3>

<p>yy    //将当前行复制到缓存区，也可以用 “ayy 复制，”a 为缓冲区，a也可以替换为a到z的任意字母，可以完成多个复制任务。<br>nyy   //将当前行向下n行复制到缓冲区，也可以用 “anyy 复制，”a 为缓冲区，a也可以替换为a到z的任意字母，可以完成多个复制任务。<br>yw    //复制从光标开始到词尾的字符。<br>nyw   //复制从光标开始的n个单词。<br>y^      //复制从光标到行首的内容。  VPS侦探<br>y$      //复制从光标到行尾的内容。<br>p        //粘贴剪切板里的内容在光标后，如果使用了前面的自定义缓冲区，建议使用”ap 进行粘贴。<br>P        //粘贴剪切板里的内容在光标前，如果使用了前面的自定义缓冲区，建议使用”aP 进行粘贴。</p>
<h3>九、替换(vi命令模式下使用)</h3>

<p>:s/old/new      //用new替换行中首次出现的old<br>:s/old/new/g         //用new替换行中所有的old<br>:n,m s/old/new/g     //用new替换从n到m行里所有的old<br>:%s/old/new/g      //用new替换当前文件里所有的old</p>
<h3>十、编辑其他文件</h3>

<p>:e otherfilename    //编辑文件名为otherfilename的文件。</p>
<h3>十一、修改文件格式</h3>

<p>:set fileformat=unix   //将文件修改为unix格式，如win下面的文本文件在linux下会出现^M。</p>
]]></content>
         
         
           
             
              <breadCrumb title="linux" url="www.lkh.im/categories/linux/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>www.lkh.im/2014/12/20/virtualbox%E5%A4%8D%E5%88%B6centos%E8%99%9A%E6%8B%9F%E6%9C%BA/</loc>
    <lastmod>2014-12-27T06:14:36.000Z</lastmod>
    <data>
        <display>
        <title>virtualbox复制centos虚拟机</title>
        <pubTime>2014-12-20T06:30:47.000Z</pubTime>
        
        <tag>虚拟机 </tag>
         
        <tag>centos </tag>
         
         <content><![CDATA[<ol>
<li>右键选择选择已经装好的centos系统，点击复制，进去下图</li>
</ol>
<p>这里把名字取为centos 172.16.3.165 代表ip修改为165，并选择重新生成mac地址</p>
<p> <img src="/images/2014/12/20/6.jpeg" alt=""> </p>
<ol>
<li><p>选择完全复制</p>
<p><img src="/images/2014/12/20/7.jpeg" alt=""> </p>
</li>
</ol>
<p>复制完成后，启动centos 172.16.3.165 这台虚拟机</p>
<p>3.进去虚拟机，查看虚拟机的网络环境 输入ifconfig</p>
<p> <img src="/images/2014/12/20/8.jpeg" alt="">  </p>
<p>由上图看出目前的ip是155。需要注意的是，这里的mac地址是旧的虚拟机的地址，需要改成virtualbox分配的新mac地址，具体操作如下</p>
<p>4.把mac地址改成virtualbox分配的新的mac地址</p>
<p>先删除/etc/udev/rules.d/70-persistent-net.rules文件,重启后会自动生成</p>
<p>修改/etc/sysconfig/network-script/ifcfg-eth0</p>
<p>BOOTPROTO=static</p>
<p>ONBOOT=yes</p>
<p>TYPE=Ethernet</p>
<p>IPADDR=172.16.3.165      //虚拟机的ip</p>
<p>NETMASK=255.255.255.0  //子网掩码</p>
<p>GATEWAY=172.16.3.254   //网关</p>
<p>HWADDR=08：00：27：CC:E3：79  //MAC地址 </p>
<p> 这里是mac地址可以在右键(virtualbox的虚拟机—》设置—》网络)查询到</p>
<p>如下图红色部分：</p>
<p> <img src="/images/2014/12/20/9.jpeg" alt=""> </p>
<p>然后需要添加dns</p>
<p>vi /etc/resolv.conf</p>
<p>nameserver 202.96.128.86 </p>
<p>最后reboot</p>
]]></content>
         
         
           
             
              <breadCrumb title="运维" url="www.lkh.im/categories/%E8%BF%90%E7%BB%B4/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>www.lkh.im/2014/12/20/ubuntu12-04-%E5%9C%A8virtualbox%E4%B8%8B%E6%A1%A5%E6%8E%A5-centos-%E8%99%9A%E6%8B%9F%E6%9C%BA/</loc>
    <lastmod>2014-12-27T06:14:05.000Z</lastmod>
    <data>
        <display>
        <title>ubuntu12.04 在virtualbox下桥接 centos 虚拟机</title>
        <pubTime>2014-12-20T06:08:06.000Z</pubTime>
        
        <tag>ubuntu </tag>
         
        <tag>linux </tag>
         
        <tag>centos </tag>
         
         <content><![CDATA[<h2 id="1-主机的网络环境">1.主机的网络环境</h2>
<p><img src="/images/2014/12/20/1.jpeg" alt=""> </p>
<h2 id="2-设置virualbox的网络连接方式">2.设置virualbox的网络连接方式</h2>
<p><img src="/images/2014/12/20/2.jpeg" alt=""><br>选择桥接网络，并选择eth0</p>
<h2 id="3-修改虚拟机的网络配置">3.修改虚拟机的网络配置</h2>
<p>修改/etc/sysconfig/network-script/ifcfg-eth0</p>
<p>BOOTPROTO=static</p>
<p>ONBOOT=yes</p>
<p>TYPE=Ethernet</p>
<p>IPADDR=172.16.3.166      //虚拟机的ip</p>
<p>NETMASK=255.255.255.0  //子网掩码</p>
<p>GATEWAY=172.16.3.254   //网关</p>
<p>然后需要添加dns</p>
<p>vi /etc/resolv.conf</p>
<p>nameserver 202.96.128.86 </p>
<p>重启网络</p>
<p>service network restart</p>
<p>再查看虚拟机的ip，eth0的ip已经变修改成更主机相同的网段<br><img src="/images/2014/12/20/3.jpeg" alt=""> </p>
<p>并ping通主机<br><img src="/images/2014/12/20/4.jpeg" alt=""> </p>
<p>再尝试通过主机shh到centos虚拟上<br><img src="/images/2014/12/20/5.jpeg" alt=""> </p>
<p>现在主机和虚拟机已经是通个网段上，并且连通了</p>
]]></content>
         
         
           
             
              <breadCrumb title="运维" url="www.lkh.im/categories/%E8%BF%90%E7%BB%B4/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>www.lkh.im/2014/12/20/redis%E7%9A%845%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</loc>
    <lastmod>2014-12-27T06:13:44.000Z</lastmod>
    <data>
        <display>
        <title>redis的5种数据类型及基本操作</title>
        <pubTime>2014-12-20T06:36:17.000Z</pubTime>
        
        <tag>redis </tag>
         
        <tag>缓存 </tag>
         
        <tag>cache </tag>
         
         <content><![CDATA[<h2 id="Redis支持5种类型的数据类型">Redis支持5种类型的数据类型</h2>
<h1 id="1-字符串">1.字符串</h1>
<p>Redis字符串是字节序列。Redis字符串是二进制安全的，这意味着他们有一个已知的长度没有任何特殊字符终止，所以你可以存储任何东西，512兆为上限。</p>
<p>例子</p>
<pre><code><span class="input"><span class="prompt">redis 127.0.0.1:6379&gt;</span> <span class="constant">SET</span> name <span class="string">"hang"</span></span>
<span class="input"><span class="prompt">
OK

redis 127.0.0.1:6379&gt;</span> <span class="constant">GET</span> name</span>

<span class="string">"hang"</span>
</code></pre><h1 id="2-哈希">2.哈希</h1>
<p>Redis的哈希是键值对的集合。 Redis的哈希值是字符串字段和字符串值之间的映射，因此它们被用来表示对象</p>
<p>例子</p>
<pre><code><span class="input"><span class="prompt">redis 127.0.0.1:6379&gt;</span> <span class="constant">HMSET</span> <span class="symbol">user:</span><span class="number">1</span> username hang password hang points <span class="number">200</span></span>
<span class="input"><span class="prompt">
OK

redis 127.0.0.1:6379&gt;</span> <span class="constant">HGETALL</span> <span class="symbol">user:</span><span class="number">1</span></span>

<span class="number">1</span>) <span class="string">"username"</span>

<span class="number">2</span>) <span class="string">"hang"</span>

<span class="number">3</span>) <span class="string">"password"</span>

<span class="number">4</span>) <span class="string">"hang"</span>

<span class="number">5</span>) <span class="string">"points"</span>

<span class="number">6</span>) <span class="string">"200"</span>
</code></pre><p>在上面的例子中的哈希数据类型，用于存储其中包含的用户的基本信息用户的对象。这里HMSET，HEGTALL用户命令user:1是键。可以理解成user类id=1的实例</p>
<h1 id="3-列表">3.列表</h1>
<p>Redis的列表是简单的字符串列表，排序插入顺序。您可以添加元素到Redis的列表的头部或尾部。</p>
<p>例子</p>
<pre><code><span class="input"><span class="prompt">redis 127.0.0.1:6379&gt;</span> lpush tutoriallist redis</span>
<span class="input"><span class="prompt">
(integer) 1

redis 127.0.0.1:6379&gt;</span> lpush tutoriallist mongodb</span>
<span class="input"><span class="prompt">
(integer) 2

redis 127.0.0.1:6379&gt;</span> lpush tutoriallist rabitmq</span>
<span class="input"><span class="prompt">
(integer) 3

redis 127.0.0.1:6379&gt;</span> lrange tutoriallist <span class="number">0</span> <span class="number">10</span></span>

<span class="number">1</span>) <span class="string">"rabitmq"</span>

<span class="number">2</span>) <span class="string">"mongodb"</span>

<span class="number">3</span>) <span class="string">"redis"</span>
</code></pre><p>列表的最大长度为 232 - 1 元素（4294967295，每个列表中可容纳超过4十亿的元素），改类型可以理解为java中的list集合</p>
<h1 id="4-集合">4.集合</h1>
<p>Redis的集合是字符串的无序集合。在Redis您可以添加，删除和测试文件是否存在，在成员O（1）的时间复杂度。</p>
<p>例子</p>
<pre><code><span class="input"><span class="prompt">redis 127.0.0.1:6379&gt;</span> sadd tutoriallist2 redis</span>
<span class="input"><span class="prompt">
(integer) 1

redis 127.0.0.1:6379&gt;</span> sadd tutoriallist2 mongodb</span>
<span class="input"><span class="prompt">
(integer) 1

redis 127.0.0.1:6379&gt;</span> sadd tutoriallist2 rabitmq</span>
<span class="input"><span class="prompt">
(integer) 1

redis 127.0.0.1:6379&gt;</span> sadd tutoriallist2 rabitmq</span>
<span class="input"><span class="prompt">
(integer) 0

redis 127.0.0.1:6379&gt;</span> smembers tutoriallist2 </span>

<span class="number">1</span>) <span class="string">"rabitmq"</span>

<span class="number">2</span>) <span class="string">"mongodb"</span>

<span class="number">3</span>) <span class="string">"redis"</span>
</code></pre><p>注意：在上面的例子中rabitmq集合添加加两次，但由于集合元素具有唯一属性，该类型可以理解为java中的hashset集合</p>
<p>集合中的元素最大数量为 232 - 1 （4294967295，可容纳超过4十亿元素）。</p>
<h1 id="5-_Redis有序集">5. Redis有序集</h1>
<p>Redis的有序集合类似Redis的集合存储在设定值具有唯一性。不同的是，一个有序集合的每个成员用分数，以便采取有序set命令，从最小的到最大的分数有关。</p>
<p>在Redis的有序set添加，删除和测试存在成员O（1）（固定时间，无论里面包含集合元素的数量）。列表的最大长度为 232 - 1 个元素（每集合超过4294967295元素）。</p>
<p>例子</p>
<pre><code><span class="input"><span class="prompt">redis 127.0.0.1:6379&gt;</span> <span class="constant">ZADD</span> tutorials3 <span class="number">1</span> redis</span>
<span class="input"><span class="prompt">
(integer) 1

redis 127.0.0.1:6379&gt;</span> <span class="constant">ZADD</span> tutorials3 <span class="number">2</span> mongodb</span>
<span class="input"><span class="prompt">
(integer) 1

redis 127.0.0.1:6379&gt;</span> <span class="constant">ZADD</span> tutorials3 <span class="number">3</span> mysql</span>
<span class="input"><span class="prompt">
(integer) 1

redis 127.0.0.1:6379&gt;</span> <span class="constant">ZADD</span> tutorials3 <span class="number">3</span> mysql</span>
<span class="input"><span class="prompt">
(integer) 0

redis 127.0.0.1:6379&gt;</span> <span class="constant">ZADD</span> tutorials3 <span class="number">4</span> mysql</span>
<span class="input"><span class="prompt">
(integer) 0

redis 127.0.0.1:6379&gt;</span> <span class="constant">ZRANGE</span> tutorials3 <span class="number">0</span> <span class="number">10</span> <span class="constant">WITHSCORES</span></span>



<span class="number">1</span>) <span class="string">"redis"</span>

<span class="number">2</span>) <span class="string">"1"</span>

<span class="number">3</span>) <span class="string">"mongodb"</span>

<span class="number">4</span>) <span class="string">"2"</span>

<span class="number">5</span>) <span class="string">"mysql"</span>

<span class="number">6</span>) <span class="string">"4"</span>
</code></pre><p>在上述例子中的三个值被命令ZADD插入其得分在redis的有序集命名为tutorials3。最终打印出每个元素以及对应的下标。</p>
<p>也可以只遍历出集合的元素</p>
<pre><code><span class="input"><span class="prompt">redis 127.0.0.1:6379&gt;</span> <span class="constant">ZRANGEBYSCORE</span> tutoriallist3 <span class="number">0</span> <span class="number">1000</span></span>

<span class="number">1</span>) <span class="string">"redis"</span>

<span class="number">2</span>) <span class="string">"mongodb"</span>

<span class="number">3</span>) <span class="string">"rabitmq"</span>
</code></pre><p>该类型可以理解为java中的linkedhashset</p>
]]></content>
         
         
           
             
              <breadCrumb title="缓存" url="www.lkh.im/categories/%E7%BC%93%E5%AD%98/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>www.lkh.im/2014/12/20/jdbcTemplate/</loc>
    <lastmod>2014-12-27T06:13:16.000Z</lastmod>
    <data>
        <display>
        <title>jdbcTemplate</title>
        <pubTime>2014-12-20T03:43:20.000Z</pubTime>
        
        <tag>java </tag>
         
        <tag>jdbcTemplate </tag>
         
         <content><![CDATA[<h1 id="Jdbctemplate_的基本使用">Jdbctemplate 的基本使用</h1>
<p>依赖：</p>
<pre><code><span class="tag">&lt;<span class="title">dependencies</span>&gt;</span>
    <span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
        <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
        <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
        <span class="tag">&lt;<span class="title">version</span>&gt;</span>4.1.3.RELEASE<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
    <span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
        <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>commons-dbcp<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
        <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>commons-dbcp<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
        <span class="tag">&lt;<span class="title">version</span>&gt;</span>1.4<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
    <span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
        <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
        <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
        <span class="tag">&lt;<span class="title">version</span>&gt;</span>4.1.3.RELEASE<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
    <span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
        <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
        <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
        <span class="tag">&lt;<span class="title">version</span>&gt;</span>4.0.5.RELEASE<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
        <span class="tag">&lt;<span class="title">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="title">scope</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
    <span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
        <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
        <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
        <span class="tag">&lt;<span class="title">version</span>&gt;</span>1.8.4<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
<span class="comment">&lt;!-- jdbc driver --&gt;</span>
<span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
        <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
        <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
        <span class="tag">&lt;<span class="title">version</span>&gt;</span>5.1.21<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
        <span class="tag">&lt;<span class="title">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="title">scope</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependencies</span>&gt;</span>
</code></pre><p>建立数据库表：</p>
<pre><code><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`user`</span> (
  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,
  <span class="string">`username`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,
  <span class="string">`password`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,
  <span class="string">`createDate`</span> datetime <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,
  <span class="string">`modifyDate`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,
  <span class="string">`type`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,
  <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (<span class="string">`id`</span>)
) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">223</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span>
</code></pre><p>aplicationContext.xml的配置</p>
<pre><code><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="tag">&lt;<span class="title">beans</span> <span class="attribute">xmlns</span>=<span class="value">"http://www.springframework.org/schema/beans"</span>
<span class="attribute">xmlns:mvc</span>=<span class="value">"http://www.springframework.org/schema/mvc"</span>
<span class="attribute">xmlns:xsi</span>=<span class="value">"http://www.w3.org/2001/XMLSchema-instance"</span>
<span class="attribute">xmlns:context</span>=<span class="value">"http://www.springframework.org/schema/context"</span>
<span class="attribute">xmlns:aop</span>=<span class="value">"http://www.springframework.org/schema/aop"</span>
<span class="attribute">xmlns:tx</span>=<span class="value">"http://www.springframework.org/schema/tx"</span>
<span class="attribute">xsi:schemaLocation</span>=<span class="value">"http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans-3.1.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context-3.1.xsd
       http://www.springframework.org/schema/aop
       http://www.springframework.org/schema/aop/spring-aop-3.1.xsd
       http://www.springframework.org/schema/tx
       http://www.springframework.org/schema/tx/spring-tx-3.1.xsd"</span>&gt;</span>
<span class="comment">&lt;!-- 扫描包 --&gt;</span>
<span class="tag">&lt;<span class="title">context:annotation-config</span>/&gt;</span>
    <span class="tag">&lt;<span class="title">context:component-scan</span> <span class="attribute">base-package</span>=<span class="value">"com.hang.*"</span> /&gt;</span>
<span class="comment">&lt;!-- 配置jdbc --&gt;</span>
<span class="tag">&lt;<span class="title">bean</span> <span class="attribute">class</span>=<span class="value">"org.springframework.beans.factory.config.PreferencesPlaceholderConfigurer"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"locations"</span>&gt;</span>
            <span class="tag">&lt;<span class="title">value</span>&gt;</span>classpath:jdbc.properties<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">bean</span>&gt;</span>
<span class="comment">&lt;!-- 配置數據源 --&gt;</span>
<span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"dataSource"</span> <span class="attribute">class</span>=<span class="value">"org.apache.commons.dbcp.BasicDataSource"</span>
<span class="attribute">destroy-method</span>=<span class="value">"close"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"driverClassName"</span> <span class="attribute">value</span>=<span class="value">"${jdbc.driver}"</span> /&gt;</span>
        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"url"</span> <span class="attribute">value</span>=<span class="value">"${jdbc.url}"</span> /&gt;</span>
        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"username"</span> <span class="attribute">value</span>=<span class="value">"${jdbc.username}"</span> /&gt;</span>
        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"password"</span> <span class="attribute">value</span>=<span class="value">"${jdbc.password}"</span> /&gt;</span>
<span class="comment">&lt;!-- 连接池启动时的初始值 --&gt;</span>
<span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"initialSize"</span> <span class="attribute">value</span>=<span class="value">"${initialSize}"</span>/&gt;</span>
        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"maxActive"</span> <span class="attribute">value</span>=<span class="value">"${maxActive}"</span>/&gt;</span>
        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"maxIdle"</span> <span class="attribute">value</span>=<span class="value">"${maxIdle}"</span>/&gt;</span>
        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"minIdle"</span> <span class="attribute">value</span>=<span class="value">"${minIdle}"</span>/&gt;</span>
    <span class="tag">&lt;/<span class="title">bean</span>&gt;</span>
<span class="comment">&lt;!-- 配置jdbcTemplate模板 --&gt;</span>
<span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"jdbcTemplate"</span> <span class="attribute">class</span>=<span class="value">"org.springframework.jdbc.core.JdbcTemplate"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"dataSource"</span> <span class="attribute">ref</span>=<span class="value">"dataSource"</span> /&gt;</span>
    <span class="tag">&lt;/<span class="title">bean</span>&gt;</span>
<span class="comment">&lt;!-- 配置 transactionManager事物管理--&gt;</span>
<span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"transactionManager"</span> <span class="attribute">class</span>=<span class="value">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"dataSource"</span> <span class="attribute">ref</span>=<span class="value">"dataSource"</span>/&gt;</span>
    <span class="tag">&lt;/<span class="title">bean</span>&gt;</span>
<span class="comment">&lt;!-- Spring AOP config配置切点 --&gt;</span>
<span class="tag">&lt;<span class="title">aop:config</span>&gt;</span>
        <span class="tag">&lt;<span class="title">aop:pointcut</span> <span class="attribute">expression</span>=<span class="value">"execution(* com.hang.service.*.*(..))"</span> <span class="attribute">id</span>=<span class="value">"bussinessService"</span> /&gt;</span>
        <span class="tag">&lt;<span class="title">aop:advisor</span> <span class="attribute">advice-ref</span>=<span class="value">"txAdvice"</span> <span class="attribute">pointcut-ref</span>=<span class="value">"bussinessService"</span>/&gt;</span>
    <span class="tag">&lt;/<span class="title">aop:config</span>&gt;</span>
<span class="comment">&lt;!-- 配置那个类那个方法用到事务处理 --&gt;</span>
<span class="tag">&lt;<span class="title">tx:advice</span> <span class="attribute">id</span>=<span class="value">"txAdvice"</span> <span class="attribute">transaction-manager</span>=<span class="value">"transactionManager"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">tx:attributes</span>&gt;</span>
            <span class="tag">&lt;<span class="title">tx:method</span> <span class="attribute">name</span>=<span class="value">"get*"</span> <span class="attribute">read-only</span>=<span class="value">"true"</span>/&gt;</span>
            <span class="tag">&lt;<span class="title">tx:method</span> <span class="attribute">name</span>=<span class="value">"add*"</span> <span class="attribute">propagation</span>=<span class="value">"REQUIRED"</span>/&gt;</span>
            <span class="tag">&lt;<span class="title">tx:method</span> <span class="attribute">name</span>=<span class="value">"update*"</span> <span class="attribute">propagation</span>=<span class="value">"REQUIRED"</span>/&gt;</span>
            <span class="tag">&lt;<span class="title">tx:method</span> <span class="attribute">name</span>=<span class="value">"delete*"</span> <span class="attribute">propagation</span>=<span class="value">"REQUIRED"</span>/&gt;</span>
            <span class="tag">&lt;<span class="title">tx:method</span> <span class="attribute">name</span>=<span class="value">"*"</span> <span class="attribute">propagation</span>=<span class="value">"REQUIRED"</span>/&gt;</span>
        <span class="tag">&lt;/<span class="title">tx:attributes</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">tx:advice</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">beans</span>&gt;</span>
</code></pre><p>Jdbc.properties</p>
<pre><code>jdbc.<span class="variable">driver=</span>com.mysql.jdbc.Driver
jdbc.<span class="variable">url=</span>jdbc:mysql://localhost:<span class="number">3306</span>/jdbcTemplate?<span class="variable">useUnicode=</span><span class="constant">true</span>&amp;amp;<span class="variable">characterEncoding=</span>UTF-<span class="number">8</span>
jdbc.<span class="variable">username=</span>root
jdbc.<span class="variable">password=</span><span class="variable">rootinitialSize=</span><span class="number">1</span>
<span class="variable">maxActive=</span><span class="number">500</span>
<span class="variable">maxIdle=</span><span class="number">2</span>
<span class="variable">minIdle=</span><span class="number">1</span>             
</code></pre><p>建立User对象</p>
<pre><code><span class="keyword">package</span> com.hang.entity;
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>{

   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1</span>L;
   <span class="keyword">private</span> <span class="keyword">int</span> id;
   <span class="keyword">private</span> String password;
   <span class="keyword">private</span> String username;
   <span class="keyword">private</span> String createDate;
   <span class="keyword">private</span> String modifyDate;
   <span class="keyword">private</span> String type;
<span class="javadoc">/** 省略set get 方法**/</span>
}
</code></pre><p>建立JdbcTempBaseDao，用于获取 jdbcTemplate对象的公共类</p>
<pre><code><span class="keyword">package</span> com.hang.dao.base;
<span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;
<span class="keyword">import</span> org.springframework.jdbc.core.support.JdbcDaoSupport;
<span class="keyword">import</span> javax.annotation.PostConstruct;
<span class="keyword">import</span> javax.annotation.Resource;
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcTempBaseDao</span> <span class="keyword">extends</span> <span class="title">JdbcDaoSupport</span> </span>{

   <span class="javadoc">/**
    */</span>
<span class="annotation">@Resource</span>(name = <span class="string">"jdbcTemplate"</span>)
   <span class="keyword">public</span> JdbcTemplate jdbcTemplate;
<span class="annotation">@PostConstruct</span>  
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initSqlMapClient</span>() {  
         <span class="keyword">super</span>.setJdbcTemplate(jdbcTemplate);
} 
}
</code></pre><p>建立IUserDao接口，对userDao的基本操作</p>
<pre><code><span class="keyword">package</span> com.hang.dao;
<span class="keyword">import</span> com.hang.entity.User;
<span class="keyword">import</span> java.util.List;
<span class="keyword">import</span> java.util.Map;
<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUserDao</span> </span>{
   <span class="keyword">public</span> List&lt;User&gt; <span class="title">getUserList</span>();
   <span class="keyword">public</span> List&lt;User&gt; <span class="title">getUserLists</span>(Map&lt;String, Object&gt; map);
   <span class="keyword">public</span> Integer <span class="title">getUserCount</span>(Map&lt;String, Object&gt; map);
   <span class="keyword">public</span> User <span class="title">getUserById</span>(Integer primaryKeyId);
   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delUserById</span>(Integer primaryKeyId);
   <span class="keyword">public</span> User <span class="title">addUser</span>(User entity);
   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">editUser</span>(User entity);
}
</code></pre><p>IUserDao 的实现</p>
<pre><code><span class="keyword">package</span> com.hang.dao.impl;
<span class="keyword">import</span> com.hang.dao.IUserDao;
<span class="keyword">import</span> com.hang.dao.base.JdbcTempBaseDao;
<span class="keyword">import</span> com.hang.entity.User;
<span class="keyword">import</span> org.springframework.jdbc.core.BeanPropertyRowMapper;
<span class="keyword">import</span> org.springframework.jdbc.core.PreparedStatementCreator;
<span class="keyword">import</span> org.springframework.jdbc.core.RowCallbackHandler;
<span class="keyword">import</span> org.springframework.jdbc.support.GeneratedKeyHolder;
<span class="keyword">import</span> org.springframework.stereotype.Repository;
<span class="keyword">import</span> java.sql.Connection;
<span class="keyword">import</span> java.sql.PreparedStatement;
<span class="keyword">import</span> java.sql.ResultSet;
<span class="keyword">import</span> java.sql.SQLException;
<span class="keyword">import</span> java.util.ArrayList;
<span class="keyword">import</span> java.util.List;
<span class="keyword">import</span> java.util.Map;
<span class="annotation">@Repository</span>
<span class="annotation">@SuppressWarnings</span>(<span class="string">"all"</span>)
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">extends</span> <span class="title">JdbcTempBaseDao</span> <span class="keyword">implements</span> <span class="title">IUserDao</span> </span>{

   <span class="annotation">@Override</span>
<span class="keyword">public</span> List&lt;User&gt; <span class="title">getUserList</span>() {
      String sql=<span class="string">"select * from user "</span>;
      <span class="keyword">final</span> List&lt;User&gt;  list= <span class="keyword">new</span> ArrayList&lt;User&gt;();
jdbcTemplate.query(sql, <span class="keyword">new</span> RowCallbackHandler(){
         <span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processRow</span>(ResultSet rs) <span class="keyword">throws</span> SQLException {
            User u=<span class="keyword">new</span> User();
u.setId(rs.getInt(<span class="string">"id"</span>));
u.setUsername(rs.getString(<span class="string">"username"</span>));
u.setPassword(rs.getString(<span class="string">"password"</span>));
u.setCreateDate(rs.getString(<span class="string">"createDate"</span>));
u.setModifyDate(rs.getString(<span class="string">"modifyDate"</span>));
u.setType(rs.getString(<span class="string">"type"</span>));
list.add(u);
}
      });
      <span class="keyword">return</span> list;
}

   <span class="annotation">@Override</span>
<span class="keyword">public</span> List&lt;User&gt; <span class="title">getUserLists</span>(Map&lt;String, Object&gt; map) {
      <span class="keyword">return</span> <span class="keyword">null</span>;
}

   <span class="annotation">@Override</span>
<span class="keyword">public</span> Integer <span class="title">getUserCount</span>(Map&lt;String, Object&gt; map) {
       String sql = <span class="string">"select count(1) from User where id=? "</span>;
        <span class="keyword">return</span> getJdbcTemplate().queryForObject(sql, Integer.class,map);
}

   <span class="annotation">@Override</span>
<span class="keyword">public</span> User <span class="title">getUserById</span>(Integer primaryKeyId) {
      String sql = <span class="string">"select id,username, password, createDate, modifyDate,type from User where id=?"</span>;
List&lt;User&gt; userList = getJdbcTemplate().query(sql, <span class="keyword">new</span> BeanPropertyRowMapper(User.class), primaryKeyId);
        <span class="keyword">if</span>(userList.size() == <span class="number">0</span>) {
            <span class="keyword">return</span> <span class="keyword">null</span>;
}
        <span class="keyword">return</span> userList.get(<span class="number">0</span>);
}

   <span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delUserById</span>(Integer primaryKeyId) {
       String sql = <span class="string">"delete from user where id=?"</span>;
getJdbcTemplate().update(sql, primaryKeyId);
}

   <span class="annotation">@Override</span>
<span class="keyword">public</span> User <span class="title">addUser</span>(<span class="keyword">final</span> User entity) {
      <span class="keyword">final</span> String sql = <span class="string">"insert into User(username, password, createDate, modifyDate,type) values(?,?,?,?,?)"</span>;
GeneratedKeyHolder keyHolder = <span class="keyword">new</span> GeneratedKeyHolder();
getJdbcTemplate().update(<span class="keyword">new</span> PreparedStatementCreator() {
            <span class="annotation">@Override</span>
<span class="keyword">public</span> PreparedStatement <span class="title">createPreparedStatement</span>(Connection connection) <span class="keyword">throws</span> SQLException {
                PreparedStatement psst = connection.prepareStatement(sql, <span class="keyword">new</span> String[]{<span class="string">"id"</span>});
psst.setString(<span class="number">1</span>, entity.getUsername());
psst.setString(<span class="number">2</span>, entity.getPassword());
psst.setString(<span class="number">3</span>, entity.getCreateDate());
psst.setString(<span class="number">4</span>, entity.getModifyDate());
psst.setString(<span class="number">5</span>, entity.getType());
                <span class="keyword">return</span> psst;
}
        }, keyHolder);
entity.setId(keyHolder.getKey().intValue());
        <span class="keyword">return</span> entity;
}

   <span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">editUser</span>(User entity) {
      String sql=<span class="string">"update user set username=?,password=?"</span>;
jdbcTemplate.update(sql, User.class,entity);
} 
}
</code></pre><p>UserDaoTest，对userdao的测试</p>
<pre><code><span class="keyword">import</span> com.hang.dao.IUserDao;
<span class="keyword">import</span> com.hang.entity.User;
<span class="keyword">import</span> org.junit.BeforeClass;
<span class="keyword">import</span> org.junit.Test;
<span class="keyword">import</span> org.springframework.context.ApplicationContext;
<span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;
<span class="keyword">import</span> java.util.List;
<span class="javadoc">/**
 * Created with IntelliJ IDEA.
 * User: hang
 * Date: 14-12-18
 * Time: 上午11:44
 * To change this template use File | Settings | File Templates.
 */</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoTest</span></span>{

    <span class="keyword">private</span> <span class="keyword">static</span> IUserDao userDao;
<span class="annotation">@BeforeClass</span>
<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setUpBeforeClass</span>() {
        ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"aplicationContext.xml"</span>);
userDao = (IUserDao) applicationContext.getBean(<span class="string">"userDaoImpl"</span>);
}

    <span class="annotation">@Test</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUserList</span>(){
        List&lt;User&gt; users = userDao.getUserList();
System.out.println(users.size());
}
}
</code></pre>]]></content>
         
         
           
             
              <breadCrumb title="java" url="www.lkh.im/categories/java/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>www.lkh.im/2014/12/20/centos6%E4%B8%8B%E5%AE%89%E8%A3%85redis/</loc>
    <lastmod>2014-12-27T06:12:53.000Z</lastmod>
    <data>
        <display>
        <title>centos6下安装redis</title>
        <pubTime>2014-12-20T06:46:11.000Z</pubTime>
        
        <tag>redis </tag>
         
        <tag>centos </tag>
         
        <tag>cache </tag>
         
         <content><![CDATA[<p>安装ridis前，先安装gcc和tcl</p>
<p>gcc的安装:</p>
<pre><code><span class="comment">yum</span> <span class="comment">install</span> <span class="comment">gcc</span><span class="literal">-</span><span class="comment">c</span><span class="literal">+</span><span class="literal">+</span>
</code></pre><p>tcl的安装:</p>
<pre><code>yum install -<span class="keyword">y</span> <span class="keyword">tcl</span>
</code></pre><p>安装完成后，开始安装redis，先下载redis的源码并编译</p>
<pre><code><span class="title">wget</span> <span class="url">http://download.redis.io/redis-stable.tar.gz</span>

tar xvzf redis-stable.tar.gz

cd redis-stable

make
</code></pre><p>在make成功以后，会在src目录下多出一些可执行文件：redis-server，redis-cli等等。</p>
<p>方便期间用cp命令复制到usr目录下运行。</p>
<pre><code>cp redis-server <span class="regexp">/usr/</span>local<span class="regexp">/bin/</span>

cp redis-cli <span class="regexp">/usr/</span>local<span class="regexp">/bin/</span>
</code></pre><p>然后新建目录，存放配置文件</p>
<pre><code><span class="built_in">mkdir</span> /etc/redis

<span class="built_in">mkdir</span> /var/redis

<span class="built_in">mkdir</span> /var/redis/<span class="built_in">log</span>

<span class="built_in">mkdir</span> /var/redis/run

<span class="built_in">mkdir</span> /var/redis/<span class="number">6379</span>
</code></pre><p>在redis解压根目录中找到配置文件模板，复制到如下位置。</p>
<pre><code><span class="keyword">cp</span> redis.<span class="keyword">conf</span> /etc/redis/<span class="number">6379</span>.<span class="keyword">conf</span>
</code></pre><p>通过vim命令修改 /etc/redis/6379.conf</p>
<pre><code>    daemonize yes

    pidfile <span class="regexp">/var/</span>redis<span class="regexp">/run/</span>redis_6379.pid

    logfile <span class="regexp">/var/</span>redis<span class="regexp">/log/</span>redis_6379.log

    dir <span class="regexp">/var/</span>redis<span class="regexp">/6379</span>
</code></pre><p>最后运行redis：       </p>
<pre><code>$ redis-server /etc/redis/<span class="number">6379</span>.<span class="keyword">conf</span> 
</code></pre><p>检查Redis是否在工作？</p>
<pre><code><span class="variable">$redis</span>-cli
</code></pre><p>这将打开一个Redis提示，如下所示：</p>
<pre><code><span class="title">redis</span> <span class="number">127.0.0.1:6379</span>&gt;
</code></pre><p>上面的提示127.0.0.1是本机的IP地址，6379为Redis服务器运行的端口。<br>现在输入PING命令，如下所示。</p>
<pre><code>    <span class="title">redis</span> <span class="number">127.0.0.1:6379</span>&gt; ping
    PONG
</code></pre><p>这说明你已经成功安装redis。</p>
<p>参考:   <a href="http://www.cnblogs.com/haoxinyue/p/3620648.html" target="_blank" rel="external">http://www.cnblogs.com/haoxinyue/p/3620648.html</a></p>
]]></content>
         
         
           
             
              <breadCrumb title="缓存" url="www.lkh.im/categories/%E7%BC%93%E5%AD%98/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>www.lkh.im/2014/12/27/LVS-%E4%B8%89%E7%A7%8D%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%E5%8E%9F%E7%90%86%E3%80%81%E4%BB%A5%E5%8F%8A%E4%BC%98%E7%BC%BA%E7%82%B9%E6%AF%94%E8%BE%83/</loc>
    <lastmod>2014-12-27T06:10:07.000Z</lastmod>
    <data>
        <display>
        <title>LVS 三种工作模式原理、以及优缺点比较</title>
        <pubTime>2014-12-27T06:05:34.000Z</pubTime>
        
        <tag>linux </tag>
         
        <tag>lvs </tag>
         
         <content><![CDATA[<h1 id="一、NAT模式（VS-NAT）">一、NAT模式（VS-NAT）</h1>
<p>原理：</p>
<p>就是把客户端发来的数据包的IP头的目的地址，在负载均衡器上换成其中一台RS 的IP地址，并发至此RS来处理,RS处理完成后把数据交给经过负载均衡器,负载均衡器再把数据包的原IP地址改为自己的IP，将目的地址改为客户端IP 地址即可｡期间,无论是进来的流量,还是出去的流量,都必须经过负载均衡器｡</p>
<p>优点：集群中的物理服务器可以使用任何支持TCP/IP操作系统，只有负载均衡器需要一个合法的IP地址。</p>
<p>缺点：扩展性有限。当服务器节点（普通PC服务器）增长过多时,负载均衡器将成为整个系统的瓶颈，因为所有的请求包和应答包的流向都经过负载均衡器。当服务器节点过多时，大量的数据包都交汇在负载均衡器那，速度就会变慢！</p>
<h1 id="二、IP隧道模式（VS-TUN）">二、IP隧道模式（VS-TUN）</h1>
<p>原理：</p>
<p>首先要知道，互联网上的大多Internet服务的请求包很短小，而应答包通常很大。那么隧道模式就是，把客户端发来的数据包，封装一个新的IP头标记(仅目的IP)发给RS,RS收到后,先把数据包的头解开,还原数据包,处理后,直接返回给客户端,不需要再经过负载均衡器｡注意,由于RS需要对负载均衡器 发过来的数据包进行还原,所以说必须支持IPTUNNEL协议｡所以,在RS的内核中,必须编译支持IPTUNNEL这个选项</p>
<p>优点：负载均衡器只负责将请求包分发给后端节点服务器，而RS将应答包直接发给用户。所以，减少了负载均衡器的大量数据流动，负载均衡器不再是系统的瓶颈，就能处理很巨大的请求量，这种方式，一台负载均衡器能够为很多RS进行分发。而且跑在公网上就能进行不同地域的分发。</p>
<p>缺点：隧道模式的RS节点需要合法IP，这种方式需要所有的服务器支持”IP Tunneling”(IP Encapsulation)协议，服务器可能只局限在部分Linux系统上。</p>
<h1 id="三、直接路由模式（VS-DR）">三、直接路由模式（VS-DR）</h1>
<p>原理：</p>
<p>负载均衡器和RS都使用同一个IP对外服务｡但只有DR对ARP请求进行响应,所有RS对本身这个IP的ARP请求保持静默｡也就是说,网关会把对这个服务 IP的请求全部定向给DR,而DR收到数据包后根据调度算法,找出对应的RS,把目的MAC地址改为RS的MAC（因为IP一致）并将请求分发给这台 RS｡这时RS收到这个数据包,处理完成之后，由于IP一致，可以直接将数据返给客户，则等于直接从客户端收到这个数据包无异,处理后直接返回给客户端｡ 由于负载均衡器要对二层包头进行改换,所以负载均衡器和RS之间必须在一个广播域,也可以简单的理解为在同一台交换机上｡</p>
<p>优点：和TUN（隧道模式）一样，负载均衡器也只是分发请求，应答包通过单独的路由方法返回给客户端。与VS-TUN相比，VS-DR这种实现方式不需要隧道结构，因此可以使用大多数操作系统做为物理服务器。</p>
<p>缺点：（不能说缺点，只能说是不足）要求负载均衡器的网卡必须与物理网卡在一个物理段上。</p>
]]></content>
         
         
           
             
              <breadCrumb title="运维" url="www.lkh.im/categories/%E8%BF%90%E7%BB%B4/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>www.lkh.im/2014/12/20/hello-world/</loc>
    <lastmod>2014-12-19T08:15:22.000Z</lastmod>
    <data>
        <display>
        <title>Hello World</title>
        <pubTime>2014-12-20T05:59:31.000Z</pubTime>
        
         <content><![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">trobuleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick_Start">Quick Start</h2>
<h3 id="Create_a_new_post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>

<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run_server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>

<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate_static_files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>

<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy_to_remote_sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>

<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
         
         
           
        </display>
    </data>
    </url>

</urlset>
