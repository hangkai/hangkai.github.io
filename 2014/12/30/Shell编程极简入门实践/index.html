
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="baidu_union_verify" content="d1952c66cf48912e21c18c7c581f382a">
  <meta name="360-site-verification" content="67fbcc5a67f4c65c057315b28fa0b2c8" />
<meta name="google-site-verification" content="2GzxQ0VtXwTSUdmGm6DzcmhTzM_I9QmzCb_pzpMzD88" />
  
    <title>Shell编程极简入门实践 | Hang&#39;s blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, minimum-scale=1">
    
    <meta name="author" content="hang">
    
    <meta name="description" content="写在前面

程序员多多少少都会和命令行打交道，一些常用的命令，比如cd、ls、ping等等，使用起来可能问题不大。但大多数人对Shell编程的了解程度，可能仅止于那几个最常用的命令。当需要更复杂的命令或者需要写一个脚本来进行批处理的时候，很多人可能感到头疼。而Unix/Linux复杂多变而又不太直观">
    
    
    
    
    <link rel="alternate" href="atom.xml" title="Hang&#39;s blog" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">

    
    <script>
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            var _bdId ='391982416296a0d54221f59fe35250d4';
             hm.src = "//hm.baidu.com/hm.js?" + _bdId;
             var s = document.getElementsByTagName("script")[0]; 
             s.parentNode.insertBefore(hm, s);
        })();
    </script>
     
</head>

  <body>
    <header>
      <div>
		
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Hang&#39;s blog">Hang&#39;s blog</a></h1>
				<a class="blog-motto">你简单，世界就是童话；心复杂，世界就是迷宫</a>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">首页</a></li>
					
						<li><a href="/archives">归档</a></li>
					
					<li>
					
                                            <form class="search" action=http://search.lkh.im/cse/search target="_blank">
                                            <label>Search</label>
                                        <input name="s" type="hidden" value= 7885676667158166336 ><input type="text" name="q" size="30" placeholder="搜索"><br>
					
					</li>
				</ul>
                            </nav>			
</div>

    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2014/12/30/Shell编程极简入门实践/" title="Shell编程极简入门实践" itemprop="url">Shell编程极简入门实践</a>
  </h1>
  <p class="article-author">By
    
      <a href="www.lkh.im" title="hang">hang</a>
    </p>
  <p class="article-time">
    <time datetime="2014-12-30T09:04:40.000Z" itemprop="datePublished">12月 30 2014</time>
    更新日期:<time datetime="2014-12-30T09:31:43.000Z" itemprop="dateModified">12月 30 2014</time>
    
  </p>
</header>
	<div class="article-content">
		
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		
		</div>
		
		<ol>
<li>写在前面</li>
</ol>
<p>程序员多多少少都会和命令行打交道，一些常用的命令，比如cd、ls、ping等等，使用起来可能问题不大。但大多数人对Shell编程的了解程度，可能仅止于那几个最常用的命令。当需要更复杂的命令或者需要写一个脚本来进行批处理的时候，很多人可能感到头疼。而Unix/Linux复杂多变而又不太直观的命令常常让初学者望而却步。比如像这样的语句echo “123 abc” | sed ‘s/[0-9][0-9]*/&amp; &amp;/‘的语句，再比如那些以-开头的参数（-l -n -a等等），即使从网上找到了可能符合自己要求的代码，也往往因为看不懂而无法修改化为己用。<br>这个极简教程，或者说笔记，针对的是正是这部分读者。具体地说，通过学习这篇文档，你将获得以下技能：<br>    熟练掌握Unix/Linux下的最常用命令及其最常见用法；<br>    能够编写脚本，对文件进行批处理，对一些网络任务进行自动化等等；<br>    避免写脚本过程中的最常见错误；<br>    (Hopefully)可以借此消除对命令行的恐惧；</p>
<p>这个教程的特点是：<br>    不求全面，只求实用。只覆盖最常用的命令及其用法；<br>    以大量例子为导向；<br>    一边阅读一边动手写例程的话，大约只需要1.5-2.5小时的时间；</p>
<p>这篇文档假定你是在Linux/Unix环境下，比如Ubuntu, 比如Mac OS X。同时假定你至少了解一门其它的编程语言。这个教程的代码均在Mac OS下测试过，由于各种shell的标准差别很小，（有充足的理由相信）在别的平台应该也都能顺利运行。</p>
<ol>
<li>Hello World</li>
</ol>
<p>首先打开你用得最顺手的文本编辑器，在第一、二行分别打入</p>
<pre><code><span class="shebang">#!/bin/bash</span>
<span class="built_in">echo</span> <span class="string">"Hello, World!"</span>
</code></pre><p>保存文件，文件可保存在你喜欢的文件夹，扩展名选择.sh，比如这样的文件：tutorial.sh。</p>
<p>接着，打开命令行工具Terminal，首先将工作目录改到你保存文件的文件夹，比如如果你将tutorial.sh放在/Users/Steven/code,则在命令行里执行以下操作</p>
<pre><code><span class="built_in">cd</span> /Users/Steven/code
</code></pre><p>cd是change directory的意思，因为我们要执行tutorial.sh这个脚本，所以我们要先将工作目录转到这个脚本对应的文件夹下面。接着，在命令行继续输入</p>
<pre><code>chmod +<span class="keyword">x</span> tutorial.<span class="keyword">sh</span>
</code></pre><p>chmod是change mode，+x的意思是将tutorial.sh变为一个可执行的文件。</p>
<p>接下来，我们就可以运行tutorial.sh这个脚本了。在命令行里打入</p>
<pre><code>./tutorial.<span class="keyword">sh</span>
</code></pre><p>如无意外，你将看到命令行里返回Hello, World!这个字符串！请注意，文件名前面的./是必不可少的，它告诉系统，就在当前的目录查找一个叫tutorial.sh的文件，如果没有./，系统会只在系统目录里面查找（准确来说是PATH变量定义的路径）。</p>
<p>我们回头来看看tutorial.sh里面的程序，目前它只有两行：</p>
<pre><code><span class="shebang">#!/bin/bash</span>
<span class="built_in">echo</span> <span class="string">"Hello, World!"</span>
</code></pre><p>-#!是一个标记，它告诉系统该去哪里去寻找能“解释”tutorial.sh的解释器。 echo是回响的意思，意思是说echo后面的那一串东西，都会在命令行显示出来。它和其它语言的print是类似的。</p>
<p>就这样，我们完成了一个最简单的bash scripting的程序编写。这里面有几点需要注意：</p>
<pre><code>执行脚本文件前，先要<span class="built_in">cd</span>到文件所在的目录；
执行脚本文件前，先要chmod +x tutorial.sh将其变为可执行程序；
脚本文件的第一行，记得写上<span class="comment">#!/bin/bash。</span>
</code></pre><ol>
<li>整数和字符串</li>
</ol>
<p>变量的定义很简单，按照以下格式就可以了：</p>
<pre><code><span class="attribute">NAME</span>=<span class="string">var</span>
</code></pre><p>比如定义一个字符串：</p>
<pre><code>NAME=<span class="string">'Steven'</span>
</code></pre><p>比如定义一个整型变量：</p>
<pre><code><span class="attribute">NUM</span>=<span class="string">3</span>
</code></pre><p>这里有几点要注意，一是变量的名字，虽然大小写不限，但按照惯例一般采用全大写的方式。第二点特别重要，让我们做一个小实验来说明一下。打开刚才的那个tutorial.sh文件，将之前的内容清空，并打入</p>
<pre><code><span class="shebang">#!/bin/bash</span>
NAME = <span class="string">'Steven'</span>
<span class="built_in">echo</span> <span class="variable">$NAME</span>
</code></pre><p>如果你是直接复制以上的代码段，那么命令行应该会出现以下错误信息：</p>
<pre><code>./tutorial.sh: <span class="built_in">line</span> <span class="number">2</span>: NAME: <span class="command"><span class="keyword">command</span> <span class="title">not</span> <span class="title">found</span></span>
</code></pre><p>出现这个错误，是因为：定义变量时，=的前面和后面，都是不能有空格的！这一点可能和其它语言不一样，但请务必注意。因为出现这类错误时，报错信息定位的栏数（line 2），是指向你引用变量的那一段代码，而不是定义变量的那一行，因此debug起来可能不是那么直观。</p>
<p>于是，我们把代码改为：</p>
<pre><code><span class="shebang">#!/bin/bash</span>
NAME=<span class="string">'Steven'</span>
<span class="built_in">echo</span> <span class="variable">$NAME</span>
</code></pre><p>命令行将显示Steven。</p>
<p>从上面的例子我们也可以看到，当你定义了一个变量，要引用它时，要在前面加上$。变量名两边可以加上花括号，比如这样${NAME}。花括号不是必须的，但最好养成加上的习惯。因为在某些情况下，不加花括号可能引发歧义[1]:</p>
<pre><code><span class="shebang">#!/bin/bash</span>
NAME=<span class="string">'Steven'</span>
<span class="built_in">echo</span> <span class="string">"My name is <span class="variable">${NAME}</span>SLXie."</span>
</code></pre><p>可想而知，如果没有花括号，NAME和后面的SLXie就无法区分了。</p>
<p>对于字符串变量，既可以用单括号，比如’Steven’，也可以用双括号”Steven”，它们之间有微妙而繁杂的区别，在这里我们先记住一点，当字符串里面包含对某个变量的引用时，必须用双括号。比如上面的”My name is ${NAME}SLXie.”。请试着将它的双括号改为单括号，并观察它的输出结果。</p>
<p>单括号会将被引用字符串中的几乎所有特殊字符当作普通字符处理，比如上面的$，单括号时只把它当作一个普通的美元符号输出。</p>
<p>再看一个例子，试着在脚本分别输入这两行，并观察它们的输出。</p>
<pre><code><span class="built_in">echo</span> <span class="string">"Here is <span class="variable">$50</span>."</span>
<span class="built_in">echo</span> <span class="string">'Here is $50.'</span>
</code></pre><p>在这里插播一句，看这个教程的时候，最好是看到那里，就动手写到哪里。写的时候，不要直接复制粘贴，而是试着手打代码到编辑器里面。有时候代码里有一些微小而琐碎的东西，一定要自己打一遍才能记得牢。比如，一开始可能容易将#!/bin/bash打成#/bin/bash，或者#!bin/bash。</p>
<p>花括号{}也可以用来对字符串进行某些操作。比如下面这个例子：</p>
<pre><code><span class="shebang">#!/bin/bash</span>
USERNAME=<span class="string">'StevenSLXie'</span>
<span class="built_in">echo</span> <span class="string">"My name is <span class="variable">${USERNAME}</span>. People usually call me <span class="variable">${USERNAME:0:6}</span>."</span>
</code></pre><p>它会输出：</p>
<pre><code>My name <span class="keyword">is</span> StevenSLXie. People usually <span class="built_in">call</span> <span class="keyword">me</span> Steven.
</code></pre><p>这时候，${USERNAME:0:6}的作用是取字符串的一部分。第一个数字0是指截取的起始部分，则第二个数字6则是指截取的长度。再比如${#USERNAME}则是获取字符串的长度。更多的字符串用法，我们将在后面的正则表达式哪一节看到。</p>
<ol>
<li>数组</li>
</ol>
<p>数组可以这样简单粗暴地定义：</p>
<pre><code>NAMES[<span class="number">0</span>]=<span class="string">'Steven'</span>
NAMES[<span class="number">1</span>]=<span class="string">'Peter'</span>
NAMES[<span class="number">2</span>]=<span class="string">'David'</span>
</code></pre><p>当数组体量太大时，这样定义未免麻烦，因此我们也可以用一行声明的方式来定义：</p>
<pre><code><span class="keyword">declare</span> <span class="operator">-a</span> NAMES=(<span class="string">'Steven'</span> <span class="string">'Peter'</span> <span class="string">'David'</span>)
</code></pre><p>用declare -a来声明，后面一次性定义所有数组元素。请注意，在这里，整个数组用小括号括起来，而每个数组元素之间，是用空格来隔开的，而不是逗号或者其它。</p>
<p>访问数组的其中一个元素，和其它语言没什么不同。在你声明好数组之后，就可以访问数组元素了：</p>
<pre><code><span class="built_in">echo</span> <span class="variable">${NAMES[0]}</span>
<span class="built_in">echo</span> <span class="variable">${NAMES[2]}</span>
<span class="built_in">echo</span> <span class="variable">${NAMES[*]}</span>
</code></pre><p>${NAMES[<em>]}或者${NAMES[@]}表示访问所有元素。而${#NAMES[</em>]}则返回数组长度。请注意它和${#NAMES}的区别，后者是返回NAMES里面第一个元素的长度，相当于${#NAMES[0]}。</p>
<p>一个数组声明并定义后，我们仍可以二次定义它，比如下面的代码是在原来的数组基础上再添加一个人名。</p>
<pre><code><span class="keyword">declare</span> <span class="operator">-a</span> NAMES=(<span class="string">'Steven'</span> <span class="string">'Peter'</span> <span class="string">'David'</span>)
<span class="built_in">echo</span> <span class="variable">${#NAMES[*]}</span>
NAMES=(<span class="string">"<span class="variable">${NAMES[*]}</span>"</span> <span class="string">'Nancy'</span>)
<span class="built_in">echo</span> <span class="variable">${NAMES[*]}</span>
</code></pre><p>命令行将返回：</p>
<pre><code>3
Steven Peter David Nancy
</code></pre><ol>
<li>运算符<br>4.1 算术运算符</li>
</ol>
<p>Shell编程里的算术运算符和大多数编程语言很类似，主要是这些+ - * / %等。如果你试着在命令行里执行运算的话，比如输入以下算式：</p>
<pre><code>2 + 2
</code></pre><p>会得到：</p>
<pre><code>-<span class="ruby"><span class="symbol">bash:</span> <span class="number">2</span><span class="symbol">:</span> command <span class="keyword">not</span> found</span>
</code></pre><p>这条错误信息。这是因为命令行的逻辑是它会把一行命令的第一个词当作是命令，在系统中寻找与之匹配的执行语句，因为在这里它会认为2是一个命令，而显然它不可能找到这个命令。要想执行运算，我们在命令行里打入</p>
<pre><code><span class="type">expr</span> <span class="number">2</span> + <span class="number">2</span>
</code></pre><p>输出结果是4。expr是一个常用命令，evaluate an expression的意思。注意，这里数字和运算符之间，必须有一个空格。不然的话，如果你输入，</p>
<pre><code><span class="type">expr</span> <span class="number">2</span>+<span class="number">2</span>
</code></pre><p>则会输出</p>
<pre><code>2+2
</code></pre><p>这种情况下，expr会把后面的2+2当成一个字符串，而evaluate一个字符串的结果，自然就是它本身了。算术运算当然也可以用变量，比如：</p>
<pre><code><span class="keyword">VAR</span>=<span class="number">5</span>
expr <span class="number">2</span> + ${<span class="keyword">VAR</span>}
</code></pre><p>其它的算术运算符大体类似，但有一个要特别注意，如果你进行乘法运算，比如:</p>
<pre><code><span class="type">expr</span> <span class="number">2</span> * <span class="number">15</span>
</code></pre><p>会输出：</p>
<pre><code><span class="attribute">expr</span>: <span class="string">syntax error</span>
</code></pre><p>这是因为*是一个特殊的字符（后面还会介绍到），而当要表达其原来的意思是，我们需要在它前面加上下划线\。就像这样：</p>
<pre><code><span class="type">expr</span> <span class="number">2</span> \* <span class="number">15</span>
</code></pre><p>4.2 关系判断运算符</p>
<p>Shell提供了丰富的关系判断运算符，先来看一个例子，在tutorial.sh加入以下代码：</p>
<pre><code>A=<span class="number">10</span>
B=<span class="number">15</span>

<span class="keyword">if</span> [ <span class="variable">$A</span> <span class="operator">-eq</span> <span class="variable">$B</span> ]
<span class="keyword">then</span>
    <span class="built_in">echo</span> <span class="string">'True'</span>
<span class="keyword">else</span>
    <span class="built_in">echo</span> <span class="string">'False'</span>
<span class="keyword">fi</span>
</code></pre><p>这是一个if条件判别语句(后面再细讲)。-eq判断运算符左右两边是否相等，如果是，则返回True，不然就返回False。关系判断运算符的基本格式是[ VAR1 OPERATOR VAR2 ]，用一个中括号括起来，这里有一点细节要注意，中括号和变量之间，需要有空格隔开。所以像[$A -eq $B]是会报错的。（不如自己写段代码试一试？）</p>
<p>完整的关系判断运算符文档可以看这里：Unix Basic Operator<br>4.3 逻辑运算符</p>
<p>与主流编程语言用&amp;&amp; and || or来做逻辑判断稍有不同，Shell编程里，与逻辑和或逻辑分别是用-o和-a来表示的。看看下面这个例子：</p>
<pre><code>A=<span class="number">10</span>
B=<span class="number">15</span>

<span class="keyword">if</span> [ <span class="variable">$A</span> <span class="operator">-lt</span> <span class="number">8</span> <span class="operator">-a</span> <span class="variable">$B</span> <span class="operator">-gt</span> <span class="number">8</span> ]
<span class="keyword">then</span>
    <span class="built_in">echo</span> <span class="string">'True'</span>
<span class="keyword">else</span>
    <span class="built_in">echo</span> <span class="string">'False'</span>
<span class="keyword">fi</span>
</code></pre><p>这是判断变量A是否小于8且变量B是否大于B。</p>
<p>完整的关系判断运算符文档可以看这里：Unix Basic Operator</p>
<ol>
<li>if条件判断、while循环、for循环</li>
</ol>
<p>if | while | for语句和其它主流语言很相似，因此用起来应该不是大问题。值得注意的可能是以下几个小点：</p>
<pre><code><span class="keyword">if</span>语句的格式是<span class="keyword">if</span>...<span class="keyword">then</span>...<span class="keyword">elif</span>...fi。注意，这里用fi来标记一个条件判断的结束。嗯，感觉是一种很调皮的设定。
所有的<span class="keyword">while</span>和<span class="keyword">for</span>语句，其执行的语句都始于<span class="keyword">do</span>，终于<span class="keyword">done</span>。
<span class="keyword">for</span>的格式是<span class="keyword">for</span> VAR <span class="keyword">in</span> ARRAY，是Python的样式，和经典的C <span class="keyword">for</span>循环可能稍有不同。
</code></pre><p>下面我们用一个例子来感受一下这三种语句。</p>
<pre><code><span class="built_in">echo</span> <span class="string">'Shall we begin the demo?(y/n)'</span>
<span class="built_in">read</span> ANS

A=<span class="number">0</span>
<span class="keyword">declare</span> <span class="operator">-a</span> B=(<span class="number">0</span>)

<span class="keyword">if</span> [ <span class="variable">$ANS</span> = <span class="string">'y'</span> ]
<span class="keyword">then</span>
    <span class="built_in">echo</span> <span class="string">'Output the results of the while loop'</span>
    <span class="keyword">while</span> [ <span class="variable">$A</span> <span class="operator">-lt</span> <span class="number">10</span> ]
    <span class="keyword">do</span>
        <span class="built_in">echo</span> <span class="variable">$A</span>
        A=`expr <span class="variable">$A</span> + <span class="number">1</span>`
        B=(<span class="variable">${B[*]}</span> <span class="variable">$A</span>)
    <span class="keyword">done</span>
<span class="keyword">else</span>
    <span class="built_in">echo</span> <span class="string">'Not ready for the demo yet.'</span>
<span class="keyword">fi</span>

<span class="built_in">echo</span> <span class="string">'Output the results of the for loop.'</span>
<span class="keyword">for</span> I <span class="keyword">in</span> <span class="variable">${B[*]}</span>
    <span class="keyword">do</span>
        <span class="built_in">echo</span> <span class="variable">$I</span>
    <span class="keyword">done</span>
</code></pre><p>第二行的read在这个文档是第一次出现，它的功能是从Terminal里读取一行，并将这一行内容赋给read后面的那个变量。在这个例子里，我们询问用户是否要开始demo，当得到肯定回答后，用户的回答（假定是y），将被赋给ANS这个变量。</p>
<p>接着，我们用一个if判断语句，如果用户回答是y，则执行while循环。while循环的内容比较简单，在每一次循环里，先打印出A的值，接着将A的值加一，然后将每一个得到的新的A放进数组B里面。当A大于等于10的时候，退出循环。</p>
<p>最后是一个for循环，for的功能是将数组B里面的元素依次打印出来。</p>
<p>这里要补充一点，在对A加一的时候，我们使用的是A=<code>expr $A + 1</code>，如果你试图使用类似A=$A + 1这样的赋值，将会报错。这是因为如前所述，每一个算术运算，都需要用expr来算出它的结果。那expr两边的<code>`又是怎么回事呢？这里的</code> <code>其实是命令输出的引用，我们知道expr $A + 1本身是一个命令语句，而当我们要引用这个语句的执行结果的时候，就要加上</code> <code>了。举一个比较容易理解的例子吧：如果你在命令行输入date，就会输出系统的当前时间，这时候date是一个命令，但如果你要将date这个命令的执行结果赋给一个变量D，就要D=</code>date<code>。同样的，如果我们要将5 + 25的结果赋给一个变量SUM，则需要SUM=</code>expr 5 + 25`。</p>
<p><code> </code>在键盘上的位置是在Tab上面，1的左边。</p>
<p>还有一点要注意，当我们对一个已经定义过的变量进行重新赋值的时候，是不需要加$的，上面的例子A=<code>expr $A + 1</code>和B=(${B[*]} $A)里，等式左边的变量都不需要加$。</p>
<ol>
<li>函数</li>
</ol>
<p>Shell脚本里当然可以定义函数。比如这样的：</p>
<pre><code><span class="function"><span class="title">hello</span></span>(){
    <span class="built_in">echo</span> <span class="string">"Hello World!"</span>
}
</code></pre><p>函数可以直接调用，比如下面这个脚本：</p>
<pre><code><span class="shebang">#!/bin/bash</span>
<span class="function"><span class="title">hello</span></span>(){
    <span class="built_in">echo</span> <span class="string">"Hello World!"</span>
}

hello
</code></pre><p>注意，但函数没有参数时，调用只需要写上函数名，而不是hello()之类的。</p>
<p>Shell函数的特殊之处，在于它参数传递的形式，具体地说，参数并不是像别的语言一样，写在括号里面，而是类似下面这个例子：</p>
<pre><code><span class="function"><span class="title">intro</span></span>(){
    <span class="built_in">echo</span> <span class="string">"There are <span class="variable">$1</span> people here. They are <span class="variable">$2</span>, <span class="variable">$3</span>."</span>
}
</code></pre><p>Shell用$1 $2这样的特殊记号来标记函数参数。而$0则是函数名，$n表示第n个参数。调用上面的intro函数，则是这个样子：</p>
<pre><code><span class="keyword">intro</span> <span class="number">2</span> <span class="string">'Steven'</span> <span class="string">'David'</span>
</code></pre><p>命令行的输出则是：</p>
<pre><code>There are <span class="number">2</span> people <span class="keyword">here</span>. They are Steven, David.
</code></pre><p>参数不是写在括号里，而是在函数名之后依次排列，并以空格隔开。</p>
<p>函数也可以有返回值，比如：</p>
<pre><code>hello(){
    <span class="literal">A</span>=<span class="escape">`e</span>xpr <span class="number">5</span> \* <span class="number">10</span><span class="escape">`
</span>    <span class="keyword">return</span> $<span class="literal">A</span>
}
</code></pre><p>返回变量A的值。请注意，这里获取返回值的方式和其它语言可能不太一样。并不是A=hello，而是：</p>
<pre><code><span class="attribute">hello
RET</span>=<span class="string">$?</span>
</code></pre><p>$?是一个特殊字符，它保留上一个命令的执行结果。因此，当我们要获取hello函数的返回值时，就在调用该函数后，紧接着将$?赋给存储返回值的变量ret。在这里，这两句命令是必须紧挨着的，如果中间还有其它语句，则$?会返回最近一次的命令执行结果，而不一定是hello的返回值。</p>
<ol>
<li>sed和正则表达式</li>
</ol>
<p>正则表达式是一种特殊的字符串，用来描述一串具有某种共同特征的字符串。在进行批处理的时候，正则表达式有着异常强大的应用。</p>
<p>sed则是一个流编辑器(stream editor)，它读入一个输出，并通过加工处理，输出经处理后的 文件/字符串 输出。下面我们通过一系列例子，来掌握sed的基本应用。</p>
<p>首先我们要来新建一些txt文件供sed处理。在命令行输入：</p>
<pre><code><span class="built_in">mkdir</span> <span class="keyword">files</span>
<span class="keyword">cd</span> <span class="keyword">files</span>
touch test-<span class="number">1</span>.txt
touch test-<span class="number">2</span>.txt
touch test-<span class="number">3</span>.txt
<span class="keyword">cd</span> ../
</code></pre><p>第一行mkdir是在当前目录下新建一个叫files的文件夹。然后我们cd到新的文件夹里，在里面用touch新建三个txt文档。接着，通过cd ../回到上级目录，也就是我们的tutorial.sh所在的目录里。</p>
<p>然后，分别打开那三个txt文件，将以下几行字符串拷贝到文件里。</p>
<p>This is a file with several lines<br>some of which are blank lines<br>for example, the line that follows is blank</p>
<p>But this line has several characters.</p>
<p>And this marks the end of the file.</p>
<p>接着，打开我们的tutorial.sh，将之前内容清空，只留下第一行的#!/usr/bash。在里面输入：</p>
<pre><code><span class="built_in">cd</span> files
FILE=test-<span class="number">1</span>.txt

sed -i.tmp <span class="string">"/^$/d"</span> <span class="variable">$FILE</span>
</code></pre><p>保存后运行./tutorial.sh。然后打开test-1.txt，如无意外的话，你会看到文档变成这个样子：</p>
<p>This is a file with several lines<br>some of which are blank lines<br>for example, the line that follows is blank<br>But this line has several characters.<br>And this marks the end of the file.</p>
<p>所有的空行被删除了。我们来看看sed -i.tmp “/^$/d” $FILE这句命令。其中”/^$/d”描述了sed作用于什么模式(pattern)，以及操作(action)，它的基本结构是这样的”/pattern/action”。其中pattern里面是一个正则表达式，表面了我们要寻找什么样的字符串(pattern match)，找到之后，则是对这个字符串进行操作(action)。在我们这个例子里，我们的正则表达式是”^$”，其中^是标记一个字符串的开始，而$是标记一个字符串的结束。在这里，开始和结束连在一起，表示我们要寻找的是一个空字符串，而对它的操作是d，delete的意思。整个句子合起来就是，sed会打开test-1.txt，逐行扫描，找到空行，删除掉空行。</p>
<p>而sed前面的 -i则是in place的意思，就是说我们这个操作是直接对目标文件下手的。这样的修改通常是比较危险的（万一改错了呢），所以一个安全的办法是在-i后面加上-i.tmp，意思是每次改动，我们都会保留一个后缀为.tmp的备份文件。于是你打开文件夹的话，会看到多出了一个test-1.txt.tmp。如果你确认你的改动没有问题之后，就可以把这个备份文件删掉了。备份文件的扩展名可以随意，因为当你需要它的时候总是需要把它改回txt的。但最好扩展名不要和文件夹的已有文件重复。</p>
<p>接着你可以试试将上面的sed语句改为：</p>
<pre><code>sed <span class="operator">-e</span> <span class="string">"/^$/d"</span> test-<span class="number">2</span>.txt
</code></pre><p>这时你会发现改动后的结果，在命令行显示出来了，而原文件并不会改动。</p>
<p>再来看下面的语句：</p>
<pre><code>sed <span class="operator">-e</span> <span class="string">"1,3d"</span> test-<span class="number">2</span>.txt
</code></pre><p>这个语句的意思，就是删除test-2.txt中的第一到第三行。观察输出可以看到，前三行被删除了。类似地，sed -e “2,4!d” test-2.txt则是指，除了2-4行，其他都删掉。sed -e “d” test-2.txt 则是删除文档里面的全部内容。请注意，为了避免频繁改动文档，以上几个命令都是用的-e，改动是体现在命令行的输出的。如果要直接对文档进行改动，请用-i.tmp，或者分开写为-i ‘.tmp’。在Mac OS X的Bash Shell里面，似乎提供一个备份文件的扩展名是必须的，而在Linux平台则似乎是可选的。</p>
<p>更为常见的sed的应用，是用它来进行替换。看看下面的例子：</p>
<pre><code>sed <span class="operator">-e</span> <span class="string">'s/But/but/'</span> test-<span class="number">2</span>.txt
</code></pre><p>命令行的输出：</p>
<p>This is file with several lines<br>some of which are blank lines<br>for example, the line that follows is blank</p>
<p>but this line has several characters.</p>
<p>And this marks the end of the file.</p>
<p>可以观察到，首字母大写的But被替换成but。替换的基本格式是’s/a/b/‘，a和b分别代表替换前和替换后。我们再来多看几个例子，首先将test-2.txt文档的内容改为：</p>
<p>1.This is file with several lines<br>2.some of which are blank lines<br> for example, the line that follows is blank</p>
<p>7.But this line has several characters.</p>
<p> And this marks the end of the file.</p>
<p>第三行和最后一行前面有一个空格。接着我们在tutorial.sh里面加入以下命令：</p>
<pre><code><span class="title">sed</span> -i <span class="string">'.tmp'</span> <span class="string">'s/^[ 1-3]//'</span> test-<span class="number">2</span>.txt
</code></pre><p>你会看到以下输出：</p>
<p>.This is file with several lines<br>.some of which are blank lines<br>for example, the line that follows is blank</p>
<p>7.But this line has several characters.</p>
<p>And this marks the end of the file.</p>
<p>在这个例子里，正则表达式^[ 1-3]的^表示字符串的开始，而中括号表示匹配任意一个在中括号里面的字符。我们的中括号里面有空格以及数字1-3，而之后*表示零到任意多个任意字符。于是，sed根据正则表达式的要求去逐行扫描，找出“以空格或者数字1-3开头的行”。</p>
<p>找到之后干什么呢？这就要看第二个/后面的内容了，而我们发现第二个/和第三个/之间并没有内容。这是说，找到了符合要求的这个字符串，就将其替换为空字符。于是你可以看到以上的输出了。第一行第二行的数字被移除，第三行和最后一行的空格被移除，而第五行的数字7则不受影响。</p>
<p>保留新的test-2.txt，我们继续执行以下命令：</p>
<pre><code><span class="title">sed</span> -i <span class="string">'.tmp'</span> <span class="string">'s/[!.]$/;/'</span> test-<span class="number">2</span>.txt
</code></pre><p>这个命令则是找出以! .结尾的行，并一律改为以分号结尾。</p>
<p>我们继续在原有的文档操作，输入以下命令：</p>
<pre><code><span class="title">sed</span> -i <span class="string">'.tmp'</span> <span class="string">'s/^[. 1-9]*//;s/[;.!]$/ ENDING/'</span> test-<span class="number">2</span>.txt
</code></pre><p>这是两个替换命令一起来。首先，我们找出以. 或者数字1-9,或者空格开头的行，然后将其删掉。请注意，这里有一个<em>，它代表了任意多个（包括0）前一个字符的重复。比如如果一个行是以三个空格开头的，则加上</em>可以加之一并铲除，如果不加的话就只会匹配并删除第一个空格。两个合并命令之间以空格隔开。第二个命令是找出以分号句号或者感叹号结尾的行，代之以ENDING。</p>
<p>输出结果应该是：</p>
<p>This is file with several lines<br>some of which are blank lines<br>for example, the line that follows is blank</p>
<p>But this line has several characters ENDING</p>
<p>And this marks the end of the file ENDING</p>
<p>回头看这个命令，sed -i ‘.tmp’ ‘s/^[. 1-9]*//;s/[;.!]$/ ENDING/‘ test-2.txt。两个小时之前，如果你看到这么复杂的命令行的时候，很有可能因为看起来过于复杂而崩溃掉吧。但现在，你也能读、写这样复杂的命令了。恭喜！</p>
<p>让我们继续来看看sed的一些其它应用。</p>
<pre><code><span class="title">sed</span> -i <span class="string">'.tmp'</span> <span class="string">'s/^some.*//'</span> test-<span class="number">2</span>.txt
</code></pre><p>删除以some开头的行。其中.可以指代任意字符。</p>
<pre><code><span class="title">sed</span> -i <span class="string">'.tmp'</span> <span class="string">'s/....$//'</span> test-<span class="number">2</span>.txt
</code></pre><p>删除每行末尾的四个字符。</p>
<pre><code><span class="title">sed</span> -i <span class="string">'.tmp'</span> <span class="string">'s/But/but/g'</span> test-<span class="number">2</span>.txt
</code></pre><p>这个看起来有点熟悉对不对？如果你比较之前的语句，会发现多了一个g。在这里，如果不加g则只会替换每行的第一个But，而加g则会替换所有的But。如果你只是要替换某一个位置的But，比如第三个，则可以sed -i ‘.tmp’ ‘s/But/but/3’ test-2.txt。</p>
<p>除了删除和替换，sed还支持插入(insert/append)新的字符串。</p>
<p>比如下面的例子：</p>
<pre><code>sed -i <span class="comment">'.tmp' '3 a\</span>
just some random <span class="keyword">text</span><span class="comment">' test-2.txt</span>
</code></pre><p>它的功能是往test-2.txt的第三行后面添加just some random text这一新行。注意a\之后要另起一行，这里a是append的意思。如果a\改为i\，则是在前面加新行。i是insert的意思。</p>
<p>另外一个例子：</p>
<pre><code>sed -i <span class="comment">'.tmp' '$ a\</span>
just some random <span class="keyword">text</span><span class="comment">' test-2.txt</span>
</code></pre><p>在文件末尾处加上新行。</p>
<p>当然我们也可以用正则表达式要判别，比如：</p>
<pre><code>sed -i '.tmp' '/text/ i\
<span class="operator"><span class="keyword">INSERT</span> THIS <span class="keyword">BEFORE</span> EVERY LINE CONTAINING <span class="built_in">TEXT</span><span class="string">' test-2.txt</span></span>
</code></pre><p>在每一行包含text的行前面加入INSERT THIS BEFORE EVERY LINE CONTAINING TEXT。</p>
<p>更多的sed用法，可以参考：<a href="http://www.grymoire.com/Unix/Sed.html#uh-1" target="_blank" rel="external">http://www.grymoire.com/Unix/Sed.html#uh-1</a> 。</p>
<ol>
<li>grep</li>
</ol>
<p>grep相当于Unix/Linux命令行的Google，可以快速地找出包含某个字符串的文件。让我们先将当前目录移到files子文件夹，并显示该目录下的所有文件名。</p>
<pre><code><span class="keyword">cd</span> <span class="keyword">files</span>
<span class="keyword">ls</span>
</code></pre><p>如果你按照这个教程一路走下来，现在这个文件夹里面应该有test-1.txt test-2.txt test-3.txt几个文件，以及可能的备份文件。如果不是也不要紧。接下来我们执行一个grep，来找出test-1.txt里面包含’file’的那些行。</p>
<pre><code><span class="keyword">grep</span> <span class="string">"file"</span> test-<span class="number">1</span>.txt
</code></pre><p>正常的话会输出：</p>
<p>This is file with several lines<br>And this marks the end of the file.</p>
<p>这两行包含着file。</p>
<p>grep可以同时搜索多个文件，比如这样：</p>
<pre><code>grep <span class="string">"file"</span> <span class="keyword">test</span>-<span class="number">1.</span>txt <span class="keyword">test</span>-<span class="number">2.</span>txt
</code></pre><p>输出则是：</p>
<p>test-1.txt:This is file with several lines<br>test-1.txt:And this marks the end of the file.<br>test-2.txt:This is file with several li<br>test-2.txt:And this marks the end of the file END</p>
<p>格式是文件名:字符串。当然，罗列所有的文件名，有时候很不方便。这时候可以用上模糊搜索。比如这样：</p>
<pre><code><span class="title">grep</span> <span class="string">"file"</span> test-<span class="regexp">*.txt</span>
</code></pre><p>有时候你只想知道哪些文件包含了某个字符串，而对那一行的具体内容是什么并不重要，那么可以这样：</p>
<pre><code><span class="title">grep</span> -l <span class="string">"file"</span> test-<span class="regexp">*.txt</span>
</code></pre><p>系统会打印出包含file的文件名。有的时候你想多知道一点：不想打印出整行字符串，但想知道每个文件有几行包含file，那么可以：</p>
<pre><code><span class="title">grep</span> -c <span class="string">"file"</span> test-<span class="regexp">*.txt</span>
</code></pre><p>而有时候你想知道的非常多，不仅是文件名，出现了几行，而且具体的行数也要知道，那么可以：</p>
<pre><code><span class="title">grep</span> -n <span class="string">"file"</span> test-<span class="regexp">*.txt</span>
</code></pre><p>有的时候你想知道输出相反的结果：那些不包含file的行，那么可以：</p>
<pre><code><span class="keyword">grep</span> -<span class="keyword">vn</span> <span class="string">"file"</span> test-*.txt
</code></pre><p>grep当然也支持正则表达式。要知道，grep的全称就是global regular expression print。所以“你问我支持不支持，他的名字叫全局正则表达式打印器，怎么能不支持？”（请忽略一个蛤丝的老梗~）。</p>
<p>我们来看几个例子：</p>
<pre><code><span class="title">grep</span> <span class="string">"END$"</span> test-<span class="regexp">*.txt</span>
</code></pre><p>输出结尾为END的那些行。</p>
<pre><code><span class="title">grep</span> <span class="string">"file\|But"</span> test-<span class="regexp">*.txt</span>
</code></pre><p>输出含有file或者But的行。注意|前面需要用\。</p>
<p>如果我们要搜索包含characters.的行，正确的命令是这样的：</p>
<pre><code><span class="title">grep</span> <span class="string">'characters\.'</span> test-<span class="regexp">*.txt</span>
</code></pre><p>同时试一试grep ‘characters.’ test-*.txt，看看结果有什么不同。</p>
<ol>
<li>写一个脚本吧</li>
</ol>
<p>前面九节基本上覆盖了Shell编程最基本的内容，这一节我们来动手写一个脚本，一方面是把我们之前学到的东西复习一下，串联起来。另一方面，是将之前没有覆盖到的几个常用命令介绍一下。</p>
<p>我们的任务是在当前目录下，新建一个脚本final-script.sh。然后在脚本里新建一个文件夹final，在新文件夹里批量新建十个.txt文件，命名规则为final-test-n.txt。每个文件的文档内容”This is a test file…!!”。</p>
<p>接着，将十个文件的文件名从final-test-n.txt改为Final-test-n.txt。</p>
<p>然后，删除文件内容里面的标点符号。</p>
<p>接着，将文件内容全部变成大写。</p>
<p>将改动后的文件，拷贝一份到任意一个新的文件夹。</p>
<p>请注意，这当中会出现一些我们没学到的知识，如果你发现现有的知识不足以解决问题的话，请Google之。</p>
<p>下面是我写的脚本，为了便于理解，我将各个命令都分开写了。</p>
<pre><code>    <span class="comment">#!/bin/bash</span>
    mkdir final
    <span class="built_in">cd</span> final

    <span class="keyword">declare</span> <span class="operator">-a</span> NAME
    NAME=(<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span>)


    <span class="comment"># 创建新文件。</span>

    <span class="keyword">for</span> I <span class="keyword">in</span> <span class="variable">${NAME[*]}</span>
        <span class="keyword">do</span>
            touch final-test-<span class="variable">${I}</span>.txt
        <span class="keyword">done</span>

  <span class="comment"># 往文档写入。这里使用的是echo，通过`&gt;`改变其默认输出。不妨思考一下如果用sed来实现会有什么问题？</span>

    <span class="keyword">for</span> F <span class="keyword">in</span> final-test-*.txt
        <span class="keyword">do</span>
            <span class="built_in">echo</span> <span class="string">'This is a test file...!!'</span> &gt; <span class="variable">$F</span>
        <span class="keyword">done</span>

 <span class="comment"># 文件名首字母大写。注意echo和sed的连用，以及我们引用命令的一种新方法$(command)。还有mv这个新命令。</span>

    <span class="keyword">for</span> F <span class="keyword">in</span> final-test-*.txt
        <span class="keyword">do</span>
            NEW=$(<span class="built_in">echo</span> <span class="string">"<span class="variable">$F</span>"</span> | sed <span class="operator">-e</span> <span class="string">'s/^./F/'</span>)
            mv <span class="string">"<span class="variable">$F</span>"</span> <span class="string">"<span class="variable">$NEW</span>"</span>
        <span class="keyword">done</span>

 <span class="comment"># 删除标点。</span>

    <span class="keyword">for</span> F <span class="keyword">in</span> *.txt
        <span class="keyword">do</span>
            sed -i.tmp <span class="string">'s/...!!$//'</span> <span class="variable">$F</span>
        <span class="keyword">done</span>

 <span class="comment"># 大写。注意tr的使用。</span>

    <span class="keyword">for</span> F <span class="keyword">in</span> *.txt
        <span class="keyword">do</span>
            tr <span class="string">'[:lower:]'</span> <span class="string">'[:upper:]'</span> &lt; <span class="variable">$F</span> &gt; FILE2
            mv FILE2 <span class="variable">$F</span>
        <span class="keyword">done</span>

    <span class="built_in">cd</span> ../
    mkdir repo

    <span class="built_in">cd</span> final

 <span class="comment"># 复制文件。</span>

    <span class="keyword">for</span> F <span class="keyword">in</span> *.txt
        <span class="keyword">do</span>
            cp <span class="variable">$F</span> ../repo/<span class="variable">$F</span>
        <span class="keyword">done</span>
</code></pre><p>原文地址：<a href="https://github.com/StevenSLXie/Tutorials-for-Web-Developers/blob/master/Shell%E7%BC%96%E7%A8%8B%E6%9E%81%E7%AE%80%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5.md" target="_blank" rel="external">https://github.com/StevenSLXie/Tutorials-for-Web-Developers/blob/master/Shell%E7%BC%96%E7%A8%8B%E6%9E%81%E7%AE%80%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5.md</a></p>
  
	</div>
		<footer class="article-footer clearfix">

  <div class="article-tags">
  
  <span></span> <a href="/tags/shell/">shell</a><a href="/tags/linux/">linux</a>
  </div>


<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/linux/">linux</a>
</div>



<div class="article-share" id="share">

  <div data-url="www.lkh.im/2014/12/30/Shell编程极简入门实践/" data-title="Shell编程极简入门实践 | Hang&#39;s blog" data-tsina="null" class="share clearfix">
  </div>

</div>
</footer>   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2014/12/31/Lock中使用多个条件condition/" title="Lock中使用多个条件condition">
  <strong>PREVIOUS:</strong><br/>
  <span>
  Lock中使用多个条件condition</span>
</a>
</div>


<div class="next">
<a href="/2014/12/29/使用Lock同步代码块/"  title="使用Lock同步代码块">
 <strong>NEXT:</strong><br/> 
 <span>使用Lock同步代码块
</span>
</a>
</div>

</nav>

	
<section class="comment">
	<div class="ds-thread"></div>
</section>

</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
  
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">
<div id="authorInfo">
	
		<div class="author-logo"></div>		
	
	<div class="social-list" class="clearfix">
		
		<a href="http://weibo.com/u/1934773961" target="_blank" title="weibo"></a>
		
		
		
		
		
	</div>
</div>

  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
			<li><a href="/categories/java/" title="java">java<sup>1</sup></a></li>
		
			<li><a href="/categories/linux/" title="linux">linux<sup>2</sup></a></li>
		
			<li><a href="/categories/多线程/" title="多线程">多线程<sup>3</sup></a></li>
		
			<li><a href="/categories/缓存/" title="缓存">缓存<sup>2</sup></a></li>
		
			<li><a href="/categories/运维/" title="运维">运维<sup>4</sup></a></li>
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			<li><a href="/tags/cache/" title="cache">cache<sup>2</sup></a></li>
		
			<li><a href="/tags/centos/" title="centos">centos<sup>4</sup></a></li>
		
			<li><a href="/tags/condition/" title="condition">condition<sup>1</sup></a></li>
		
			<li><a href="/tags/java/" title="java">java<sup>2</sup></a></li>
		
			<li><a href="/tags/jdbcTemplate/" title="jdbcTemplate">jdbcTemplate<sup>1</sup></a></li>
		
			<li><a href="/tags/linux/" title="linux">linux<sup>4</sup></a></li>
		
			<li><a href="/tags/lock/" title="lock">lock<sup>2</sup></a></li>
		
			<li><a href="/tags/log/" title="log">log<sup>1</sup></a></li>
		
			<li><a href="/tags/lvs/" title="lvs">lvs<sup>1</sup></a></li>
		
			<li><a href="/tags/redis/" title="redis">redis<sup>2</sup></a></li>
		
			<li><a href="/tags/shell/" title="shell">shell<sup>1</sup></a></li>
		
			<li><a href="/tags/ubuntu/" title="ubuntu">ubuntu<sup>1</sup></a></li>
		
			<li><a href="/tags/vi/" title="vi">vi<sup>1</sup></a></li>
		
			<li><a href="/tags/多线程/" title="多线程">多线程<sup>3</sup></a></li>
		
			<li><a href="/tags/线程池/" title="线程池">线程池<sup>1</sup></a></li>
		
			<li><a href="/tags/缓存/" title="缓存">缓存<sup>1</sup></a></li>
		
			<li><a href="/tags/虚拟机/" title="虚拟机">虚拟机<sup>1</sup></a></li>
		
		</ul>
</div>


  <div class="linkslist">
    <p class="asidetitle">友情链接</p>
    <ul>
        <li>
            <a title="lixumin" target="_blank" href="http://www.lixumin.com">夜半微凉</a>
        </li>
        <li>
            <a title="土鳖" target="_blank" href="http://www.only29.im">土鳖</a>
        </li>
    </ul>

</div>


  <div class="rsspart">
	<a href="atom.xml" target="_blank" title="rss">RSS 订阅</a>
</div>

  
  <div class="tagcloudlist">
    <p class="asidetitle">标签云</p>
    <div class="tagcloudlist clearfix">
       <a href="/tags/cache/" style="font-size: 13.33px;">cache</a><a href="/tags/centos/" style="font-size: 20.00px;">centos</a><a href="/tags/condition/" style="font-size: 10.00px;">condition</a><a href="/tags/java/" style="font-size: 13.33px;">java</a><a href="/tags/jdbcTemplate/" style="font-size: 10.00px;">jdbcTemplate</a><a href="/tags/linux/" style="font-size: 20.00px;">linux</a><a href="/tags/lock/" style="font-size: 13.33px;">lock</a><a href="/tags/log/" style="font-size: 10.00px;">log</a><a href="/tags/lvs/" style="font-size: 10.00px;">lvs</a><a href="/tags/redis/" style="font-size: 13.33px;">redis</a><a href="/tags/shell/" style="font-size: 10.00px;">shell</a><a href="/tags/ubuntu/" style="font-size: 10.00px;">ubuntu</a><a href="/tags/vi/" style="font-size: 10.00px;">vi</a><a href="/tags/多线程/" style="font-size: 16.67px;">多线程</a><a href="/tags/线程池/" style="font-size: 10.00px;">线程池</a><a href="/tags/缓存/" style="font-size: 10.00px;">缓存</a><a href="/tags/虚拟机/" style="font-size: 10.00px;">虚拟机</a>
    </div>
  </div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
    
            <p class="copyright"> © 2015 
		
		<a href="www.lkh.im" target="_blank" title="hang">hang</a>
		
            && Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> && Theme by <a href="http://gengbiao.me" target="_blank" title="coney">coney</a>
            </div>
</footer>
    <script src="/js/jquery-2.1.0.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      h  = $('article h2')
      ah = $('article h2'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  if(ah.length==0){
    t.css('display','none');
  }else{
    c.click(function(){
      ta.css('display', 'block').addClass('fadeIn');
    });
    o.click(function(){
      ta.css('display', 'none');
    });
    $(window).scroll(function(){
      ta.css("top",Math.max(140,320-$(this).scrollTop()));
    });
  };
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="#textlogo" class="article-back-to-top" title="Top"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="Weibo"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});     
</script>


<script type="text/javascript">
  var duoshuoQuery = {short_name:"lkh"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 





<script>
    
        var _bdImg = '8';
    
    window._bd_share_config={
        "common":{
            "bdSnsKey":{

            },
            "bdText":"",
            "bdMini":"2",
            "bdMiniList":[
                "qzone",
                "tsina",
                "weixin",
                "renren",
                "tqq",
                "tieba",
                "douban",
                "sqq",
                "diandian",
                "huaban",
                "youdao",
                "mail",
                "ty",
                "fbook",
                "twi",
                "linkedin",
                "copy",
                "print"
            ],
            "bdPic":"",
            "bdStyle":"0",
            "bdSize":"16"
        },
        "slide":{
            "type":"slide",
            "bdImg":_bdImg,
            "bdPos":"right",
            "bdTop":"350"
        },
        "image":{
            "viewList":[
                "weixin",
                "qzone",
                "tsina",
                "renren",
                "douban",
                "tqq"
            ],
            "viewText":"分享：",
            "viewSize":"16"
        },
        "selectShare":{
            "bdContainerClass":null,
            "bdSelectMiniList":[
                "weixin",
                "qzone",
                "tsina",
                "renren",
                "douban",
                "tqq"
            ]
        }
    };
    with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
</script>




<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'null', 'null');  
ga('send', 'pageview');
</script>


  </body>
</html>

